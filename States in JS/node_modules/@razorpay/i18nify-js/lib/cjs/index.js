'use strict';

// Custom Error class to extend properties to error object
class I18nifyError extends Error {
    constructor(message) {
        super(message);
        this.name = 'i18nify Error';
        this.timestamp = new Date();
        // more params like type of error/severity can be added in future for better debugging.
    }
}
/**
 * withErrorBoundary is a higher order function that takes function as parameter and wraps it in try/catch block.
 * It appends additional attributes and serves as a centralized error-handling service.
 * Usage =>
 * const wrappedUtilityFn = withErrorBoundary(utilityFn)
 *
 * @param fn utility that is wrapped in error boundary
 * @returns {Function} returns the function wrapped in try/catch block
 */
const withErrorBoundary = (fn) => {
    return function (...rest) {
        try {
            return fn.call(this, ...rest);
        }
        catch (err) {
            console.error('[i18nify Error]: ', err);
            // Currently, we are throwing the error as it is to consumers.
            // In the future, this can be modified as per our requirement, like an error logging service.
            throw new I18nifyError(err);
        }
    };
};

function getDefaultState() {
    return {
        locale: '',
        direction: '',
        country: '',
    };
}

class I18nStateManager {
    constructor() {
        this.state = getDefaultState();
    }
    static getInstance() {
        if (!I18nStateManager.instance) {
            I18nStateManager.instance = new I18nStateManager();
        }
        return I18nStateManager.instance;
    }
    static resetInstance() {
        I18nStateManager.instance = undefined;
    }
    getState() {
        return Object.assign({}, this.state);
    }
    setState(newState) {
        this.state = Object.assign(Object.assign({}, this.state), newState);
    }
    resetState() {
        this.state = getDefaultState();
    }
}
var state = I18nStateManager.getInstance();

/**
 * function to return active i18n state
 *
 *  ===== USAGE =====
 * import { getState } from '@razorpay/i18nify-js';
 *
 * console.log(getState())
 *
 * @returns i18n state
 */
const getState = () => {
    return state.getState();
};
var getState$1 = withErrorBoundary(getState);

/**
 * Function to set and override the active state in i18nify SDK
 *
 * ===== USAGE =====
 * import { setState } from "@razorpay/i18nify-js";
 * setState({locale: 'en-US'})
 *
 * @param newState data to set in i18nState instance
 */
const setState = (newState) => {
    state.setState(newState);
};
var setState$1 = withErrorBoundary(setState);

/**
 * Function to reset the active state in i18nify SDK
 *
 * ===== USAGE =====
 * import { resetState } from "@razorpay/i18nify-js";
 * resetState()
 *
 * @param newState data to set in i18nState instance
 */
const resetState = () => {
    state.resetState();
};
var resetState$1 = withErrorBoundary(resetState);

const getLocale = (options = {}) => {
    /** retrieve locale from below areas in order of preference
     * 1. options.locale (used in case if someone wants to override locale just for a specific area and not globally)
     * 2. i18nState.locale (uses locale set globally)
     * 3. navigator (in case locale is not passed or set, use it from browser's navigator)
     * */
    let locale = (options === null || options === void 0 ? void 0 : options.locale) || state.getState().locale;
    // If a specific locale is provided, use it; otherwise, use the browser's locale
    if (locale) {
        return locale;
    }
    // Check if running in a non-browser environment (e.g., Node.js or older browsers).
    if (typeof navigator === 'undefined') {
        return 'en-IN';
    }
    // Check if the browser supports the Intl object and user language preferences.
    if (window.Intl &&
        typeof window.Intl === 'object' &&
        (window.navigator.languages || window.navigator.language)) {
        const userLocales = window.navigator.languages || [
            window.navigator.language,
        ];
        return userLocales[0];
    }
    // Fallback to a supported locale or the default locale.
    return 'en-IN';
};

const getIntlInstanceWithOptions = (options = {}) => {
    const locale = getLocale(options);
    const intlOptions = (options === null || options === void 0 ? void 0 : options.intlOptions) ? Object.assign({}, options.intlOptions) : {};
    if ((options === null || options === void 0 ? void 0 : options.currency) || intlOptions.currency) {
        intlOptions.style = 'currency';
        intlOptions.currency = (options.currency || intlOptions.currency);
    }
    if (!locale)
        throw new Error(`The provided locale value is invalid. The received value was: ${locale}. Please ensure you pass a correct locale string for proper formatting.`);
    return new Intl.NumberFormat(locale || undefined, intlOptions);
};

var AFN = {
	name: "Afghani",
	minor_unit: "2",
	symbol: "؋"
};
var EUR = {
	name: "Euro",
	minor_unit: "2",
	symbol: "€"
};
var ALL = {
	name: "Lek",
	minor_unit: "2",
	symbol: "L"
};
var DZD = {
	name: "Algerian Dinar",
	minor_unit: "2",
	symbol: "د.ج"
};
var USD = {
	name: "US Dollar",
	minor_unit: "2",
	symbol: "$"
};
var AOA = {
	name: "Kwanza",
	minor_unit: "2",
	symbol: "Kz"
};
var XCD = {
	name: "East Caribbean Dollar",
	minor_unit: "2",
	symbol: "EC$"
};
var ARS = {
	name: "Argentine Peso",
	minor_unit: "2",
	symbol: "ARS"
};
var AMD = {
	name: "Armenian Dram",
	minor_unit: "2",
	symbol: "֏"
};
var AWG = {
	name: "Aruban Florin",
	minor_unit: "2",
	symbol: "Aƒ"
};
var AUD = {
	name: "Australian Dollar",
	minor_unit: "2",
	symbol: "A$"
};
var AZN = {
	name: "Azerbaijan Manat",
	minor_unit: "2",
	symbol: "₼"
};
var BSD = {
	name: "Bahamian Dollar",
	minor_unit: "2",
	symbol: "BSD"
};
var BHD = {
	name: "Bahraini Dinar",
	minor_unit: "3",
	symbol: ".د.ب"
};
var BDT = {
	name: "Taka",
	minor_unit: "2",
	symbol: "৳"
};
var BBD = {
	name: "Barbados Dollar",
	minor_unit: "2",
	symbol: "Bds$"
};
var BYN = {
	name: "Belarusian Ruble",
	minor_unit: "2",
	symbol: "Rbl"
};
var BZD = {
	name: "Belize Dollar",
	minor_unit: "2",
	symbol: "BZ$"
};
var XOF = {
	name: "CFA Franc BCEAO",
	minor_unit: "0",
	symbol: "CFA"
};
var BMD = {
	name: "Bermudian Dollar",
	minor_unit: "2",
	symbol: "BD$"
};
var INR = {
	name: "Indian Rupee",
	minor_unit: "2",
	symbol: "₹"
};
var BTN = {
	name: "Ngultrum",
	minor_unit: "2",
	symbol: "Nu."
};
var BOB = {
	name: "Boliviano",
	minor_unit: "2",
	symbol: "Bs."
};
var BOV = {
	name: "Mvdol",
	minor_unit: "2",
	symbol: "Bs"
};
var BAM = {
	name: "Convertible Mark",
	minor_unit: "2",
	symbol: "KM"
};
var BWP = {
	name: "Pula",
	minor_unit: "2",
	symbol: "P"
};
var NOK = {
	name: "Norwegian Krone",
	minor_unit: "2",
	symbol: "kr"
};
var BRL = {
	name: "Brazilian Real",
	minor_unit: "2",
	symbol: "R$"
};
var BND = {
	name: "Brunei Dollar",
	minor_unit: "2",
	symbol: "B$"
};
var BGN = {
	name: "Bulgarian Lev",
	minor_unit: "2",
	symbol: "лв."
};
var BIF = {
	name: "Burundi Franc",
	minor_unit: "0",
	symbol: "FBu"
};
var CVE = {
	name: "Cabo Verde Escudo",
	minor_unit: "2",
	symbol: "CVE"
};
var KHR = {
	name: "Riel",
	minor_unit: "2",
	symbol: "៛"
};
var XAF = {
	name: "CFA Franc BEAC",
	minor_unit: "0",
	symbol: "FCFA"
};
var CAD = {
	name: "Canadian Dollar",
	minor_unit: "2",
	symbol: "CA$"
};
var KYD = {
	name: "Cayman Islands Dollar",
	minor_unit: "2",
	symbol: "CI$"
};
var CLP = {
	name: "Chilean Peso",
	minor_unit: "0",
	symbol: "CLP"
};
var CLF = {
	name: "Unidad de Fomento",
	minor_unit: "4",
	symbol: "UF"
};
var CNY = {
	name: "Yuan Renminbi",
	minor_unit: "2",
	symbol: "CN¥"
};
var COP = {
	name: "Colombian Peso",
	minor_unit: "2",
	symbol: "COL$"
};
var COU = {
	name: "Unidad de Valor Real",
	minor_unit: "2",
	symbol: "UVR"
};
var KMF = {
	name: "Comorian Franc",
	minor_unit: "0",
	symbol: "CF"
};
var CDF = {
	name: "Congolese Franc",
	minor_unit: "2",
	symbol: "FC"
};
var NZD = {
	name: "New Zealand Dollar",
	minor_unit: "2",
	symbol: "NZ$"
};
var CRC = {
	name: "Costa Rican Colon",
	minor_unit: "2",
	symbol: "₡"
};
var HRK = {
	name: "Kuna",
	minor_unit: "2",
	symbol: "kn"
};
var CUP = {
	name: "Cuban Peso",
	minor_unit: "2",
	symbol: "$MN"
};
var CUC = {
	name: "Peso Convertible",
	minor_unit: "2",
	symbol: "CUC$"
};
var ANG = {
	name: "Netherlands Antillean Guilder",
	minor_unit: "2",
	symbol: "ƒ"
};
var CZK = {
	name: "Czech Koruna",
	minor_unit: "2",
	symbol: "Kč"
};
var DKK = {
	name: "Danish Krone",
	minor_unit: "2",
	symbol: "kr"
};
var DJF = {
	name: "Djibouti Franc",
	minor_unit: "0",
	symbol: "Fdj"
};
var DOP = {
	name: "Dominican Peso",
	minor_unit: "2",
	symbol: "RD$"
};
var EGP = {
	name: "Egyptian Pound",
	minor_unit: "2",
	symbol: "E£"
};
var SVC = {
	name: "El Salvador Colon",
	minor_unit: "2",
	symbol: "₡"
};
var ERN = {
	name: "Nakfa",
	minor_unit: "2",
	symbol: "Nfk"
};
var SZL = {
	name: "Lilangeni",
	minor_unit: "2",
	symbol: "E"
};
var ETB = {
	name: "Ethiopian Birr",
	minor_unit: "2",
	symbol: "Br"
};
var FKP = {
	name: "Falkland Islands Pound",
	minor_unit: "2",
	symbol: "FK£"
};
var FJD = {
	name: "Fiji Dollar",
	minor_unit: "2",
	symbol: "FJ$"
};
var XPF = {
	name: "CFP Franc",
	minor_unit: "0",
	symbol: "F"
};
var GMD = {
	name: "Dalasi",
	minor_unit: "2",
	symbol: "D"
};
var GEL = {
	name: "Lari",
	minor_unit: "2",
	symbol: "₾"
};
var GHS = {
	name: "Ghana Cedi",
	minor_unit: "2",
	symbol: "GH₵"
};
var GIP = {
	name: "Gibraltar Pound",
	minor_unit: "2",
	symbol: "£"
};
var GTQ = {
	name: "Quetzal",
	minor_unit: "2",
	symbol: "Q"
};
var GBP = {
	name: "Pound Sterling",
	minor_unit: "2",
	symbol: "£"
};
var GNF = {
	name: "Guinean Franc",
	minor_unit: "0",
	symbol: "FG"
};
var GYD = {
	name: "Guyana Dollar",
	minor_unit: "2",
	symbol: "GY$"
};
var HTG = {
	name: "Gourde",
	minor_unit: "2",
	symbol: "G"
};
var HNL = {
	name: "Lempira",
	minor_unit: "2",
	symbol: "L"
};
var HKD = {
	name: "Hong Kong Dollar",
	minor_unit: "2",
	symbol: "HK$"
};
var HUF = {
	name: "Forint",
	minor_unit: "2",
	symbol: "Ft"
};
var ISK = {
	name: "Iceland Krona",
	minor_unit: "0",
	symbol: "kr"
};
var IDR = {
	name: "Rupiah",
	minor_unit: "2",
	symbol: "Rp"
};
var IRR = {
	name: "Iranian Rial",
	minor_unit: "2",
	symbol: "﷼"
};
var IQD = {
	name: "Iraqi Dinar",
	minor_unit: "3",
	symbol: "ع.د"
};
var ILS = {
	name: "New Israeli Sheqel",
	minor_unit: "2",
	symbol: "₪"
};
var JMD = {
	name: "Jamaican Dollar",
	minor_unit: "2",
	symbol: "J$"
};
var JPY = {
	name: "Yen",
	minor_unit: "0",
	symbol: "¥"
};
var JOD = {
	name: "Jordanian Dinar",
	minor_unit: "3",
	symbol: "JD"
};
var KZT = {
	name: "Tenge",
	minor_unit: "2",
	symbol: "₸"
};
var KES = {
	name: "Kenyan Shilling",
	minor_unit: "2",
	symbol: "KSh"
};
var KPW = {
	name: "North Korean Won",
	minor_unit: "2",
	symbol: "₩"
};
var KRW = {
	name: "Won",
	minor_unit: "0",
	symbol: "₩"
};
var KWD = {
	name: "Kuwaiti Dinar",
	minor_unit: "3",
	symbol: "د.ك"
};
var KGS = {
	name: "Som",
	minor_unit: "2",
	symbol: "сом"
};
var LAK = {
	name: "Kip",
	minor_unit: "2",
	symbol: "₭"
};
var LBP = {
	name: "Lebanese Pound",
	minor_unit: "2",
	symbol: "L£"
};
var LSL = {
	name: "Loti",
	minor_unit: "2",
	symbol: "M"
};
var ZAR = {
	name: "South African Rand",
	minor_unit: "2",
	symbol: "R"
};
var LRD = {
	name: "Liberian Dollar",
	minor_unit: "2",
	symbol: "L$"
};
var LYD = {
	name: "Libyan Dinar",
	minor_unit: "3",
	symbol: "LD"
};
var CHF = {
	name: "Swiss Franc",
	minor_unit: "2",
	symbol: "CHF"
};
var MOP = {
	name: "Pataca",
	minor_unit: "2",
	symbol: "MOP$"
};
var MKD = {
	name: "Denar",
	minor_unit: "2",
	symbol: "ден"
};
var MGA = {
	name: "Malagasy Ariary",
	minor_unit: "2",
	symbol: "Ar"
};
var MWK = {
	name: "Malawi Kwacha",
	minor_unit: "2",
	symbol: "MK"
};
var MYR = {
	name: "Malaysian Ringgit",
	minor_unit: "2",
	symbol: "RM"
};
var MVR = {
	name: "Rufiyaa",
	minor_unit: "2",
	symbol: "Rf"
};
var MRU = {
	name: "Ouguiya",
	minor_unit: "2",
	symbol: "UM"
};
var MUR = {
	name: "Mauritian Rupee",
	minor_unit: "2",
	symbol: "₨"
};
var MXN = {
	name: "Mexican Peso",
	minor_unit: "2",
	symbol: "Mex$"
};
var MXV = {
	name: "Mexican Unidad de Inversion (UDI)",
	minor_unit: "2",
	symbol: "UDI"
};
var MDL = {
	name: "Moldovan Leu",
	minor_unit: "2",
	symbol: "L"
};
var MNT = {
	name: "Tugrik",
	minor_unit: "2",
	symbol: "₮"
};
var MAD = {
	name: "Moroccan Dirham",
	minor_unit: "2",
	symbol: "DH"
};
var MZN = {
	name: "Mozambique Metical",
	minor_unit: "2",
	symbol: "MT"
};
var MMK = {
	name: "Kyat",
	minor_unit: "2",
	symbol: "Ks"
};
var NAD = {
	name: "Namibia Dollar",
	minor_unit: "2",
	symbol: "N$"
};
var NPR = {
	name: "Nepalese Rupee",
	minor_unit: "2",
	symbol: "₨"
};
var NIO = {
	name: "Cordoba Oro",
	minor_unit: "2",
	symbol: "C$"
};
var NGN = {
	name: "Naira",
	minor_unit: "2",
	symbol: "₦"
};
var OMR = {
	name: "Rial Omani",
	minor_unit: "3",
	symbol: "ر.ع."
};
var PKR = {
	name: "Pakistan Rupee",
	minor_unit: "2",
	symbol: "₨"
};
var PAB = {
	name: "Balboa",
	minor_unit: "2",
	symbol: "B/."
};
var PGK = {
	name: "Kina",
	minor_unit: "2",
	symbol: "K"
};
var PYG = {
	name: "Guarani",
	minor_unit: "0",
	symbol: "₲"
};
var PEN = {
	name: "Sol",
	minor_unit: "2",
	symbol: "S/"
};
var PHP = {
	name: "Philippine Peso",
	minor_unit: "2",
	symbol: "₱"
};
var PLN = {
	name: "Zloty",
	minor_unit: "2",
	symbol: "zł"
};
var QAR = {
	name: "Qatari Rial",
	minor_unit: "2",
	symbol: "ر.ق"
};
var RON = {
	name: "Romanian Leu",
	minor_unit: "2",
	symbol: "lei"
};
var RUB = {
	name: "Russian Ruble",
	minor_unit: "2",
	symbol: "₽"
};
var RWF = {
	name: "Rwandan Franc",
	minor_unit: "0",
	symbol: "FRw"
};
var SHP = {
	name: "Saint Helena Pound",
	minor_unit: "2",
	symbol: "£"
};
var WST = {
	name: "Tala",
	minor_unit: "2",
	symbol: "WS$"
};
var STN = {
	name: "Dobra",
	minor_unit: "2",
	symbol: "Db"
};
var SAR = {
	name: "Saudi Riyal",
	minor_unit: "2",
	symbol: "ر.س"
};
var RSD = {
	name: "Serbian Dinar",
	minor_unit: "2",
	symbol: "дин."
};
var SCR = {
	name: "Seychelles Rupee",
	minor_unit: "2",
	symbol: "₨"
};
var SLL = {
	name: "Leone",
	minor_unit: "2",
	symbol: "Le"
};
var SGD = {
	name: "Singapore Dollar",
	minor_unit: "2",
	symbol: "S$"
};
var SBD = {
	name: "Solomon Islands Dollar",
	minor_unit: "2",
	symbol: "SI$"
};
var SOS = {
	name: "Somali Shilling",
	minor_unit: "2",
	symbol: "S"
};
var SSP = {
	name: "South Sudanese Pound",
	minor_unit: "2",
	symbol: "SS£"
};
var LKR = {
	name: "Sri Lanka Rupee",
	minor_unit: "2",
	symbol: "₨"
};
var SDG = {
	name: "Sudanese Pound",
	minor_unit: "2",
	symbol: "£"
};
var SRD = {
	name: "Surinam Dollar",
	minor_unit: "2",
	symbol: "SRD"
};
var SEK = {
	name: "Swedish Krona",
	minor_unit: "2",
	symbol: "kr"
};
var CHE = {
	name: "WIR Euro",
	minor_unit: "2",
	symbol: "CHE"
};
var CHW = {
	name: "WIR Franc",
	minor_unit: "2",
	symbol: "CHW"
};
var SYP = {
	name: "Syrian Pound",
	minor_unit: "2",
	symbol: "£"
};
var TWD = {
	name: "New Taiwan Dollar",
	minor_unit: "2",
	symbol: "NT$"
};
var TJS = {
	name: "Somoni",
	minor_unit: "2",
	symbol: "ЅМ"
};
var TZS = {
	name: "Tanzanian Shilling",
	minor_unit: "2",
	symbol: "Sh"
};
var THB = {
	name: "Baht",
	minor_unit: "2",
	symbol: "฿"
};
var TOP = {
	name: "Pa’anga",
	minor_unit: "2",
	symbol: "T$"
};
var TTD = {
	name: "Trinidad and Tobago Dollar",
	minor_unit: "2",
	symbol: "TT$"
};
var TND = {
	name: "Tunisian Dinar",
	minor_unit: "3",
	symbol: "DT"
};
var TRY = {
	name: "Turkish Lira",
	minor_unit: "2",
	symbol: "₺"
};
var TMT = {
	name: "Turkmenistan New Manat",
	minor_unit: "2",
	symbol: "T"
};
var UGX = {
	name: "Uganda Shilling",
	minor_unit: "0",
	symbol: "USh"
};
var UAH = {
	name: "Hryvnia",
	minor_unit: "2",
	symbol: "₴"
};
var AED = {
	name: "UAE Dirham",
	minor_unit: "2",
	symbol: "د.إ"
};
var UYI = {
	name: "Uruguay Peso en Unidades Indexadas (URUIURUI)",
	minor_unit: "2",
	symbol: "$U"
};
var UYU = {
	name: "Peso Uruguayo",
	minor_unit: "0",
	symbol: "$U"
};
var UYW = {
	name: "Unidad Previsional",
	minor_unit: "4",
	symbol: "UR"
};
var UZS = {
	name: "Uzbekistan Sum",
	minor_unit: "2",
	symbol: "so‘m"
};
var VUV = {
	name: "Vatu",
	minor_unit: "0",
	symbol: "VT"
};
var VES = {
	name: "Bolívar Soberano",
	minor_unit: "2",
	symbol: "Bs.S."
};
var VED = {
	name: "Bolívar Soberano",
	minor_unit: "2",
	symbol: "Bs.S."
};
var VND = {
	name: "Dong",
	minor_unit: "0",
	symbol: "₫"
};
var YER = {
	name: "Yemeni Rial",
	minor_unit: "2",
	symbol: "﷼"
};
var ZMW = {
	name: "Zambian Kwacha",
	minor_unit: "2",
	symbol: "ZK"
};
var ZWL = {
	name: "Zimbabwe Dollar",
	minor_unit: "2",
	symbol: "Z$"
};
var CURRENCY_INFO = {
	AFN: AFN,
	EUR: EUR,
	ALL: ALL,
	DZD: DZD,
	USD: USD,
	AOA: AOA,
	XCD: XCD,
	ARS: ARS,
	AMD: AMD,
	AWG: AWG,
	AUD: AUD,
	AZN: AZN,
	BSD: BSD,
	BHD: BHD,
	BDT: BDT,
	BBD: BBD,
	BYN: BYN,
	BZD: BZD,
	XOF: XOF,
	BMD: BMD,
	INR: INR,
	BTN: BTN,
	BOB: BOB,
	BOV: BOV,
	BAM: BAM,
	BWP: BWP,
	NOK: NOK,
	BRL: BRL,
	BND: BND,
	BGN: BGN,
	BIF: BIF,
	CVE: CVE,
	KHR: KHR,
	XAF: XAF,
	CAD: CAD,
	KYD: KYD,
	CLP: CLP,
	CLF: CLF,
	CNY: CNY,
	COP: COP,
	COU: COU,
	KMF: KMF,
	CDF: CDF,
	NZD: NZD,
	CRC: CRC,
	HRK: HRK,
	CUP: CUP,
	CUC: CUC,
	ANG: ANG,
	CZK: CZK,
	DKK: DKK,
	DJF: DJF,
	DOP: DOP,
	EGP: EGP,
	SVC: SVC,
	ERN: ERN,
	SZL: SZL,
	ETB: ETB,
	FKP: FKP,
	FJD: FJD,
	XPF: XPF,
	GMD: GMD,
	GEL: GEL,
	GHS: GHS,
	GIP: GIP,
	GTQ: GTQ,
	GBP: GBP,
	GNF: GNF,
	GYD: GYD,
	HTG: HTG,
	HNL: HNL,
	HKD: HKD,
	HUF: HUF,
	ISK: ISK,
	IDR: IDR,
	IRR: IRR,
	IQD: IQD,
	ILS: ILS,
	JMD: JMD,
	JPY: JPY,
	JOD: JOD,
	KZT: KZT,
	KES: KES,
	KPW: KPW,
	KRW: KRW,
	KWD: KWD,
	KGS: KGS,
	LAK: LAK,
	LBP: LBP,
	LSL: LSL,
	ZAR: ZAR,
	LRD: LRD,
	LYD: LYD,
	CHF: CHF,
	MOP: MOP,
	MKD: MKD,
	MGA: MGA,
	MWK: MWK,
	MYR: MYR,
	MVR: MVR,
	MRU: MRU,
	MUR: MUR,
	MXN: MXN,
	MXV: MXV,
	MDL: MDL,
	MNT: MNT,
	MAD: MAD,
	MZN: MZN,
	MMK: MMK,
	NAD: NAD,
	NPR: NPR,
	NIO: NIO,
	NGN: NGN,
	OMR: OMR,
	PKR: PKR,
	PAB: PAB,
	PGK: PGK,
	PYG: PYG,
	PEN: PEN,
	PHP: PHP,
	PLN: PLN,
	QAR: QAR,
	RON: RON,
	RUB: RUB,
	RWF: RWF,
	SHP: SHP,
	WST: WST,
	STN: STN,
	SAR: SAR,
	RSD: RSD,
	SCR: SCR,
	SLL: SLL,
	SGD: SGD,
	SBD: SBD,
	SOS: SOS,
	SSP: SSP,
	LKR: LKR,
	SDG: SDG,
	SRD: SRD,
	SEK: SEK,
	CHE: CHE,
	CHW: CHW,
	SYP: SYP,
	TWD: TWD,
	TJS: TJS,
	TZS: TZS,
	THB: THB,
	TOP: TOP,
	TTD: TTD,
	TND: TND,
	TRY: TRY,
	TMT: TMT,
	UGX: UGX,
	UAH: UAH,
	AED: AED,
	UYI: UYI,
	UYU: UYU,
	UYW: UYW,
	UZS: UZS,
	VUV: VUV,
	VES: VES,
	VED: VED,
	VND: VND,
	YER: YER,
	ZMW: ZMW,
	ZWL: ZWL
};

const ALLOWED_FORMAT_PARTS_KEYS$1 = [
    'nan',
    'infinity',
    'percent',
    'integer',
    'group',
    'decimal',
    'fraction',
    'plusSign',
    'minusSign',
    'percentSign',
    'currency',
    'code',
    'symbol',
    'name',
    'compact',
    'exponentInteger',
    'exponentMinusSign',
    'exponentSeparator',
    'unit',
];
const INTL_MAPPING = {
    SGD: { $: CURRENCY_INFO.SGD.symbol }, // Singapore Dollar
    XCD: { $: CURRENCY_INFO.XCD.symbol }, // East Caribbean Dollar
    ARS: { $: CURRENCY_INFO.ARS.symbol }, // Argentine Peso
    AUD: { $: CURRENCY_INFO.AUD.symbol }, // Australian Dollar
    BSD: { $: CURRENCY_INFO.BSD.symbol }, // Bahamian Dollar
    BBD: { $: CURRENCY_INFO.BBD.symbol }, // Barbados Dollar
    BMD: { $: CURRENCY_INFO.BMD.symbol }, // Bermudian Dollar
    CVE: { $: CURRENCY_INFO.CVE.symbol }, // Cabo Verde Escudo
    CAD: { $: CURRENCY_INFO.CAD.symbol }, // Canadian Dollar
    KYD: { $: CURRENCY_INFO.KYD.symbol }, // Cayman Islands Dollar
    CLP: { $: CURRENCY_INFO.CLP.symbol }, // Chilean Peso
    COP: { $: CURRENCY_INFO.COP.symbol }, // Colombian Peso
    NZD: { $: CURRENCY_INFO.NZD.symbol }, // New Zealand Dollar
    CUP: { $: CURRENCY_INFO.CUP.symbol }, // Cuban Peso
    SVC: { $: CURRENCY_INFO.SVC.symbol }, // El Salvador Colon
    FJD: { $: CURRENCY_INFO.FJD.symbol }, // Fiji Dollar
    GYD: { $: CURRENCY_INFO.GYD.symbol }, // Guyana Dollar
    HKD: { $: CURRENCY_INFO.HKD.symbol }, // Hong Kong Dollar
    JMD: { $: CURRENCY_INFO.JMD.symbol }, // Jamaican Dollar
    LRD: { $: CURRENCY_INFO.LRD.symbol }, // Liberian Dollar
    MOP: { $: CURRENCY_INFO.MOP.symbol }, // Pataca
    MXN: { $: CURRENCY_INFO.MXN.symbol }, // Mexican Peso
    NAD: { $: CURRENCY_INFO.NAD.symbol }, // Namibia Dollar
    SBD: { $: CURRENCY_INFO.SBD.symbol }, // Solomon Islands Dollar
    SRD: { $: CURRENCY_INFO.SRD.symbol }, // Surinam Dollar
    ZWL: { $: CURRENCY_INFO.ZWL.symbol }, // Zimbabwe Dollar
    LSL: { L: CURRENCY_INFO.LSL.symbol }, // Loti
    AWG: { 'Afl.': CURRENCY_INFO.AWG.symbol }, // Aruban Florin
    BYN: { Br: CURRENCY_INFO.BYN.symbol }, // Belarusian Ruble
    XAF: { FCFA: CURRENCY_INFO.XAF.symbol }, // CFA Franc BEAC
    CNY: { '¥': CURRENCY_INFO.CNY.symbol }, // Yuan Renminbi
    EGP: { '£': CURRENCY_INFO.EGP.symbol }, // Egyptian Pound
    FKP: { '£': CURRENCY_INFO.FKP.symbol }, // Falkland Islands Pound
    LBP: { '£': CURRENCY_INFO.LBP.symbol }, // Lebanese Pound
    SSP: { '£': CURRENCY_INFO.SSP.symbol }, // South Sudanese Pound
    WST: { T: CURRENCY_INFO.WST.symbol }, // Tala
};

/**
 * This function replaces the default parameters like currency symbols, currency codes, etc.,
 * returned by the JavaScript Intl API with custom values provided by a local configuration
 * (i18nify-data). This allows for customization of how different currencies or other locale-specific
 * data are represented, providing greater control over the displayed formatting.
 *
 * @param {ByParts['rawParts']} parts - An array of parts representing the formatted components
 *                                      of a currency amount, as generated by Intl.NumberFormat.
 * @param {string} currencyCode - The currency code (e.g., 'USD', 'EUR') for which the replacement
 *                                values should be applied.
 * @returns {ByParts['rawParts']} - The modified array of parts with replaced values based on the
 *                                  local i18nify configuration.
 */
const transformPartsFromIntl = (parts, currencyCode) => {
    // Loop through each part of the formatted amount
    for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        if (part.type === 'currency' && currencyCode in INTL_MAPPING) {
            const mapping = INTL_MAPPING[currencyCode];
            if (part.value in mapping) {
                parts[i].value = mapping[part.value];
                break; // Exit the loop after the first replacement
            }
        }
    }
    return parts;
};

// this function formats number based on different arguments passed
const formatNumber = (amount, options = {}) => {
    // Validate the amount parameter to ensure it is a number
    if (!Number(amount) && Number(amount) !== 0)
        throw new Error(`Parameter 'amount' is not a valid number. The received value was: ${amount} of type ${typeof amount}. Please ensure you pass a valid number.`);
    try {
        // Get an instance of Intl.NumberFormat with the provided options
        const formattedAmount = getIntlInstanceWithOptions(options).formatToParts(Number(amount));
        let parts = formattedAmount;
        const intlOptions = (options === null || options === void 0 ? void 0 : options.intlOptions) ? Object.assign({}, options.intlOptions) : {};
        const currencyCode = ((options === null || options === void 0 ? void 0 : options.currency) || intlOptions.currency);
        parts = transformPartsFromIntl(parts, currencyCode);
        // Join the parts back together to form the final formatted string
        return parts.map((p) => p.value).join('');
    }
    catch (err) {
        if (err instanceof Error) {
            throw new Error(`An error occurred while formatting the number: ${err.message}`);
        }
        else {
            throw new Error(`An unknown error occurred. Error details: ${err}`);
        }
    }
};
var formatNumber$1 = withErrorBoundary(formatNumber);

const getCurrencyList = () => {
    return CURRENCY_INFO;
};
var getCurrencyList$1 = withErrorBoundary(getCurrencyList);

const getCurrencySymbol = (currencyCode) => {
    var _a;
    const currencyInformation = CURRENCY_INFO;
    if (currencyCode in currencyInformation)
        return (_a = currencyInformation[currencyCode]) === null || _a === void 0 ? void 0 : _a.symbol;
    else
        throw new Error(`The provided currency code is invalid. The received value was: ${String(currencyCode)}. Please ensure you pass a valid currency code. Check valid currency codes here: https://github.com/razorpay/i18nify/blob/master/i18nify-data/currency/data.json`);
};
var getCurrencySymbol$1 = withErrorBoundary(getCurrencySymbol);

const formatNumberByParts = (amount, options = {}) => {
    // Validate the amount parameter to ensure it is a number
    if (!Number(amount) && Number(amount) !== 0)
        throw new Error(`Parameter 'amount' is not a valid number. The received value was: ${amount} of type ${typeof amount}. Please ensure you pass a valid number.`);
    try {
        // Get an instance of Intl.NumberFormat with the provided options
        const formattedAmount = getIntlInstanceWithOptions(options).formatToParts(Number(amount));
        let parts = formattedAmount;
        const formattedObj = {};
        const intlOptions = (options === null || options === void 0 ? void 0 : options.intlOptions) ? Object.assign({}, options.intlOptions) : {};
        const currencyCode = ((options === null || options === void 0 ? void 0 : options.currency) || intlOptions.currency);
        parts = transformPartsFromIntl(parts, currencyCode);
        parts.forEach((p) => {
            // If the part is a group separator, add it to the integer part
            if (p.type === 'group') {
                formattedObj.integer = (formattedObj.integer || '') + p.value;
            }
            else if (ALLOWED_FORMAT_PARTS_KEYS$1.findIndex((item) => item === p.type) != -1) {
                // If the part type is allowed, add it to the formatted object
                // @ts-expect-error only allowed keys are added to the formattedObj. For eg, key 'literal' is skipped
                formattedObj[p.type] = (formattedObj[p.type] || '') + p.value;
            }
        });
        return Object.assign(Object.assign({}, formattedObj), { isPrefixSymbol: parts.findIndex((item) => item.type === 'currency') <
                parts.findIndex((item) => item.type === 'integer'), rawParts: parts });
    }
    catch (err) {
        if (err instanceof Error) {
            throw new Error(`An error occurred while formatting the number: ${err.message}`);
        }
        else {
            throw new Error(`An unknown error occurred. Error details: ${err}`);
        }
    }
};
var formatNumberByParts$1 = withErrorBoundary(formatNumberByParts);

/**
 * Converts an amount from a minor currency unit to a major currency unit.
 *
 * The function takes an amount in the minor unit (e.g., cents, pence) and a currency code,
 * then converts the amount to the major unit (e.g., dollars, pounds) using the conversion rate
 * defined in the CURRENCY_INFO object. If the currency code is not supported, it throws an error.
 *
 * @param {number} amount - The amount in the minor currency unit.
 * @param {object} options - The options object
 * @returns {number} - The amount converted to the major currency unit.
 * @throws Will throw an error if the currency code is not supported.
 */
const convertToMajorUnit = (amount, options) => {
    const currencyInfo = CURRENCY_INFO[options.currency];
    if (!options.currency || !currencyInfo) {
        throw new Error(`The provided currency code is either empty or not supported. The received value was ${options.currency === '' ? 'an empty string' : `: ${String(options.currency)}`}. Please ensure you pass a valid currency code. Check valid currency codes here: https://github.com/razorpay/i18nify/blob/master/i18nify-data/currency/data.json`);
    }
    const minorUnitMultiplier = Math.pow(10, Number(currencyInfo.minor_unit)) || 100;
    const higherCurrencyValue = amount / minorUnitMultiplier;
    return higherCurrencyValue;
};
var convertToMajorUnit$1 = withErrorBoundary(convertToMajorUnit);

/**
 * Converts an amount from a major currency unit to a minor currency unit.
 *
 * The function takes an amount in the major unit (e.g., dollars, pounds) and a currency code,
 * then converts the amount to the minor unit (e.g., cents, pence) using the conversion rate
 * defined in the CURRENCY_INFO object. If the currency code is not supported, it throws an error.
 *
 * @param {number} amount - The amount in the major currency unit.
 * @param {object} options - The options object
 * @returns {number} - The amount converted to the minor currency unit.
 * @throws Will throw an error if the currency code is not supported.
 */
const convertToMinorUnit = (amount, options) => {
    const currencyInfo = CURRENCY_INFO[options.currency];
    if (!options.currency || !currencyInfo) {
        throw new Error(`The provided currency code is either empty or not supported. The received value was ${options.currency === '' ? 'an empty string' : `: ${String(options.currency)}`}. Please ensure you pass a valid currency code. Check valid currency codes here: https://github.com/razorpay/i18nify/blob/master/i18nify-data/currency/data.json`);
    }
    const minorUnitMultiplier = Math.pow(10, Number(currencyInfo.minor_unit)) || 100;
    const lowerCurrencyValue = amount * minorUnitMultiplier;
    return lowerCurrencyValue;
};
var convertToMinorUnit$1 = withErrorBoundary(convertToMinorUnit);

var AF$1 = "[2-7]\\d{8}";
var AX$1 = "2\\d{4,9}|35\\d{4,5}|(?:60\\d\\d|800)\\d{4,6}|7\\d{5,11}|(?:[14]\\d|3[0-46-9]|50)\\d{4,8}";
var AL$1 = "(?:700\\d\\d|900)\\d{3}|8\\d{5,7}|(?:[2-5]|6\\d)\\d{7}";
var DZ$1 = "(?:[1-4]|[5-79]\\d|80)\\d{7}";
var AS$1 = "(?:[58]\\d\\d|684|900)\\d{7}";
var AD$1 = "(?:1|6\\d)\\d{7}|[135-9]\\d{5}";
var AO$1 = "[29]\\d{8}";
var AI$1 = "(?:264|[58]\\d\\d|900)\\d{7}";
var AQ$1 = "";
var AG$1 = "(?:268|[58]\\d\\d|900)\\d{7}";
var AR$1 = "(?:11|[89]\\d\\d)\\d{8}|[2368]\\d{9}";
var AM$1 = "(?:[1-489]\\d|55|60|77)\\d{6}";
var AW$1 = "(?:[25-79]\\d\\d|800)\\d{4}";
var AU$1 = "1(?:[0-79]\\d{7}(?:\\d(?:\\d{2})?)?|8[0-24-9]\\d{7})|[2-478]\\d{8}|1\\d{4,7}";
var AT$1 = "1\\d{3,12}|2\\d{6,12}|43(?:(?:0\\d|5[02-9])\\d{3,9}|2\\d{4,5}|[3467]\\d{4}|8\\d{4,6}|9\\d{4,7})|5\\d{4,12}|8\\d{7,12}|9\\d{8,12}|(?:[367]\\d|4[0-24-9])\\d{4,11}";
var AZ$1 = "365\\d{6}|(?:[124579]\\d|60|88)\\d{7}";
var BS$1 = "(?:242|[58]\\d\\d|900)\\d{7}";
var BH$1 = "[136-9]\\d{7}";
var BD$1 = "[1-469]\\d{9}|8[0-79]\\d{7,8}|[2-79]\\d{8}|[2-9]\\d{7}|[3-9]\\d{6}|[57-9]\\d{5}";
var BB$1 = "(?:246|[58]\\d\\d|900)\\d{7}";
var BY$1 = "(?:[12]\\d|33|44|902)\\d{7}|8(?:0[0-79]\\d{5,7}|[1-7]\\d{9})|8(?:1[0-489]|[5-79]\\d)\\d{7}|8[1-79]\\d{6,7}|8[0-79]\\d{5}|8\\d{5}";
var BE$1 = "4\\d{8}|[1-9]\\d{7}";
var BZ$1 = "(?:0800\\d|[2-8])\\d{6}";
var BJ$1 = "[24-689]\\d{7}";
var BM$1 = "(?:441|[58]\\d\\d|900)\\d{7}";
var BT$1 = "[17]\\d{7}|[2-8]\\d{6}";
var BO$1 = "(?:[2-467]\\d\\d|8001)\\d{5}";
var BQ$1 = "(?:[34]1|7\\d)\\d{5}";
var BA$1 = "6\\d{8}|(?:[35689]\\d|49|70)\\d{6}";
var BW$1 = "(?:0800|(?:[37]|800)\\d)\\d{6}|(?:[2-6]\\d|90)\\d{5}";
var BV$1 = "";
var BR$1 = "(?:[1-46-9]\\d\\d|5(?:[0-46-9]\\d|5[0-46-9]))\\d{8}|[1-9]\\d{9}|[3589]\\d{8}|[34]\\d{7}";
var IO$1 = "3\\d{6}";
var BN$1 = "[2-578]\\d{6}";
var BG$1 = "00800\\d{7}|[2-7]\\d{6,7}|[89]\\d{6,8}|2\\d{5}";
var BF$1 = "[025-7]\\d{7}";
var BI$1 = "(?:[267]\\d|31)\\d{6}";
var CV$1 = "(?:[2-59]\\d\\d|800)\\d{4}";
var KH$1 = "1\\d{9}|[1-9]\\d{7,8}";
var CM$1 = "[26]\\d{8}|88\\d{6,7}";
var CA$1 = "(?:[2-8]\\d|90)\\d{8}|3\\d{6}";
var KY$1 = "(?:345|[58]\\d\\d|900)\\d{7}";
var CF$1 = "(?:[27]\\d{3}|8776)\\d{4}";
var TD$1 = "(?:22|[69]\\d|77)\\d{6}";
var CL$1 = "12300\\d{6}|6\\d{9,10}|[2-9]\\d{8}";
var CN$1 = "1[127]\\d{8,9}|2\\d{9}(?:\\d{2})?|[12]\\d{6,7}|86\\d{6}|(?:1[03-689]\\d|6)\\d{7,9}|(?:[3-579]\\d|8[0-57-9])\\d{6,9}";
var CX$1 = "1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}";
var CC$1 = "1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}";
var CO$1 = "(?:60\\d\\d|9101)\\d{6}|(?:1\\d|3)\\d{9}";
var KM$1 = "[3478]\\d{6}";
var CD$1 = "[189]\\d{8}|[1-68]\\d{6}";
var CG$1 = "222\\d{6}|(?:0\\d|80)\\d{7}";
var CK$1 = "[2-578]\\d{4}";
var CR$1 = "(?:8\\d|90)\\d{8}|(?:[24-8]\\d{3}|3005)\\d{4}";
var CI$1 = "[02]\\d{9}";
var HR$1 = "(?:[24-69]\\d|3[0-79])\\d{7}|80\\d{5,7}|[1-79]\\d{7}|6\\d{5,6}";
var CU$1 = "(?:[2-7]|8\\d\\d)\\d{7}|[2-47]\\d{6}|[34]\\d{5}";
var CW$1 = "(?:[34]1|60|(?:7|9\\d)\\d)\\d{5}";
var CY$1 = "(?:[279]\\d|[58]0)\\d{6}";
var CZ$1 = "(?:[2-578]\\d|60)\\d{7}|9\\d{8,11}";
var DK$1 = "[2-9]\\d{7}";
var DJ$1 = "(?:2\\d|77)\\d{6}";
var DM$1 = "(?:[58]\\d\\d|767|900)\\d{7}";
var DO$1 = "(?:[58]\\d\\d|900)\\d{7}";
var EC$1 = "1\\d{9,10}|(?:[2-7]|9\\d)\\d{7}";
var EG$1 = "[189]\\d{8,9}|[24-6]\\d{8}|[135]\\d{7}";
var SV$1 = "[267]\\d{7}|(?:80\\d|900)\\d{4}(?:\\d{4})?";
var GQ$1 = "222\\d{6}|(?:3\\d|55|[89]0)\\d{7}";
var ER$1 = "[178]\\d{6}";
var EE$1 = "8\\d{9}|[4578]\\d{7}|(?:[3-8]\\d|90)\\d{5}";
var SZ$1 = "0800\\d{4}|(?:[237]\\d|900)\\d{6}";
var ET$1 = "(?:11|[2-579]\\d)\\d{7}";
var FK$1 = "[2-7]\\d{4}";
var FO$1 = "[2-9]\\d{5}";
var FJ$1 = "45\\d{5}|(?:0800\\d|[235-9])\\d{6}";
var FI$1 = "[1-35689]\\d{4}|7\\d{10,11}|(?:[124-7]\\d|3[0-46-9])\\d{8}|[1-9]\\d{5,8}";
var FR$1 = "[1-9]\\d{8}";
var GF$1 = "[56]94\\d{6}|(?:80|9\\d)\\d{7}";
var PF$1 = "4\\d{5}(?:\\d{2})?|8\\d{7,8}";
var TF$1 = "";
var GA$1 = "(?:[067]\\d|11)\\d{6}|[2-7]\\d{6}";
var GM$1 = "[2-9]\\d{6}";
var GE$1 = "(?:[3-57]\\d\\d|800)\\d{6}";
var DE$1 = "[2579]\\d{5,14}|49(?:[34]0|69|8\\d)\\d\\d?|49(?:37|49|60|7[089]|9\\d)\\d{1,3}|49(?:2[024-9]|3[2-689]|7[1-7])\\d{1,8}|(?:1|[368]\\d|4[0-8])\\d{3,13}|49(?:[015]\\d|2[13]|31|[46][1-8])\\d{1,9}";
var GH$1 = "(?:[235]\\d{3}|800)\\d{5}";
var GI$1 = "(?:[25]\\d|60)\\d{6}";
var GR$1 = "5005000\\d{3}|8\\d{9,11}|(?:[269]\\d|70)\\d{8}";
var GL$1 = "(?:19|[2-689]\\d|70)\\d{4}";
var GD$1 = "(?:473|[58]\\d\\d|900)\\d{7}";
var GP$1 = "590\\d{6}|(?:69|80|9\\d)\\d{7}";
var GU$1 = "(?:[58]\\d\\d|671|900)\\d{7}";
var GT$1 = "80\\d{6}|(?:1\\d{3}|[2-7])\\d{7}";
var GG$1 = "(?:1481|[357-9]\\d{3})\\d{6}|8\\d{6}(?:\\d{2})?";
var GN$1 = "722\\d{6}|(?:3|6\\d)\\d{7}";
var GW$1 = "[49]\\d{8}|4\\d{6}";
var GY$1 = "(?:[2-8]\\d{3}|9008)\\d{3}";
var HT$1 = "(?:[2-489]\\d|55)\\d{6}";
var HM$1 = "";
var VA$1 = "0\\d{5,10}|3[0-8]\\d{7,10}|55\\d{8}|8\\d{5}(?:\\d{2,4})?|(?:1\\d|39)\\d{7,8}";
var HN$1 = "8\\d{10}|[237-9]\\d{7}";
var HK$1 = "8[0-46-9]\\d{6,7}|9\\d{4,7}|(?:[2-7]|9\\d{3})\\d{7}";
var HU$1 = "[235-7]\\d{8}|[1-9]\\d{7}";
var IS$1 = "(?:38\\d|[4-9])\\d{6}";
var IN$1 = "(?:000800|[2-9]\\d\\d)\\d{7}|1\\d{7,12}";
var ID$1 = "(?:(?:00[1-9]|8\\d)\\d{4}|[1-36])\\d{6}|00\\d{10}|[1-9]\\d{8,10}|[2-9]\\d{7}";
var IR$1 = "[1-9]\\d{9}|(?:[1-8]\\d\\d|9)\\d{3,4}";
var IQ$1 = "(?:1|7\\d\\d)\\d{7}|[2-6]\\d{7,8}";
var IE$1 = "(?:1\\d|[2569])\\d{6,8}|4\\d{6,9}|7\\d{8}|8\\d{8,9}";
var IM$1 = "1624\\d{6}|(?:[3578]\\d|90)\\d{8}";
var IL$1 = "1\\d{6}(?:\\d{3,5})?|[57]\\d{8}|[1-489]\\d{7}";
var IT$1 = "0\\d{5,10}|1\\d{8,10}|3(?:[0-8]\\d{7,10}|9\\d{7,8})|(?:43|55|70)\\d{8}|8\\d{5}(?:\\d{2,4})?";
var JM$1 = "(?:[58]\\d\\d|658|900)\\d{7}";
var JP$1 = "00[1-9]\\d{6,14}|[257-9]\\d{9}|(?:00|[1-9]\\d\\d)\\d{6}";
var JE$1 = "1534\\d{6}|(?:[3578]\\d|90)\\d{8}";
var JO$1 = "(?:(?:[2689]|7\\d)\\d|32|53)\\d{6}";
var KZ$1 = "(?:33622|8\\d{8})\\d{5}|[78]\\d{9}";
var KE$1 = "(?:[17]\\d\\d|900)\\d{6}|(?:2|80)0\\d{6,7}|[4-6]\\d{6,8}";
var KI$1 = "(?:[37]\\d|6[0-79])\\d{6}|(?:[2-48]\\d|50)\\d{3}";
var KP$1 = "85\\d{6}|(?:19\\d|[2-7])\\d{7}";
var KR$1 = "00[1-9]\\d{8,11}|(?:[12]|5\\d{3})\\d{7}|[13-6]\\d{9}|(?:[1-6]\\d|80)\\d{7}|[3-6]\\d{4,5}|(?:00|7)0\\d{8}";
var KW$1 = "18\\d{5}|(?:[2569]\\d|41)\\d{6}";
var KG$1 = "8\\d{9}|[235-9]\\d{8}";
var LA$1 = "[23]\\d{9}|3\\d{8}|(?:[235-8]\\d|41)\\d{6}";
var LV$1 = "(?:[268]\\d|90)\\d{6}";
var LB$1 = "[27-9]\\d{7}|[13-9]\\d{6}";
var LS$1 = "(?:[256]\\d\\d|800)\\d{5}";
var LR$1 = "(?:[245]\\d|33|77|88)\\d{7}|(?:2\\d|[4-6])\\d{6}";
var LY$1 = "[2-9]\\d{8}";
var LI$1 = "[68]\\d{8}|(?:[2378]\\d|90)\\d{5}";
var LT$1 = "(?:[3469]\\d|52|[78]0)\\d{6}";
var LU$1 = "35[013-9]\\d{4,8}|6\\d{8}|35\\d{2,4}|(?:[2457-9]\\d|3[0-46-9])\\d{2,9}";
var MO$1 = "0800\\d{3}|(?:28|[68]\\d)\\d{6}";
var MG$1 = "[23]\\d{8}";
var MW$1 = "(?:[1289]\\d|31|77)\\d{7}|1\\d{6}";
var MY$1 = "1\\d{8,9}|(?:3\\d|[4-9])\\d{7}";
var MV$1 = "(?:800|9[0-57-9]\\d)\\d{7}|[34679]\\d{6}";
var ML$1 = "[24-9]\\d{7}";
var MT$1 = "3550\\d{4}|(?:[2579]\\d\\d|800)\\d{5}";
var MH$1 = "329\\d{4}|(?:[256]\\d|45)\\d{5}";
var MQ$1 = "596\\d{6}|(?:69|80|9\\d)\\d{7}";
var MR$1 = "(?:[2-4]\\d\\d|800)\\d{5}";
var MU$1 = "(?:[57]|8\\d\\d)\\d{7}|[2-468]\\d{6}";
var YT$1 = "(?:80|9\\d)\\d{7}|(?:26|63)9\\d{6}";
var MX$1 = "[2-9]\\d{9}";
var FM$1 = "(?:[39]\\d\\d|820)\\d{4}";
var MD$1 = "(?:[235-7]\\d|[89]0)\\d{6}";
var MC$1 = "(?:[3489]|6\\d)\\d{7}";
var MN$1 = "[12]\\d{7,9}|[5-9]\\d{7}";
var ME$1 = "(?:20|[3-79]\\d)\\d{6}|80\\d{6,7}";
var MS$1 = "(?:[58]\\d\\d|664|900)\\d{7}";
var MA$1 = "[5-8]\\d{8}";
var MZ$1 = "(?:2|8\\d)\\d{7}";
var MM$1 = "1\\d{5,7}|95\\d{6}|(?:[4-7]|9[0-46-9])\\d{6,8}|(?:2|8\\d)\\d{5,8}";
var NA$1 = "[68]\\d{7,8}";
var NR$1 = "(?:444|(?:55|8\\d)\\d|666)\\d{4}";
var NP$1 = "(?:1\\d|9)\\d{9}|[1-9]\\d{7}";
var NL$1 = "(?:[124-7]\\d\\d|3(?:[02-9]\\d|1[0-8]))\\d{6}|8\\d{6,9}|9\\d{6,10}|1\\d{4,5}";
var NC$1 = "(?:050|[2-57-9]\\d\\d)\\d{3}";
var NZ$1 = "[1289]\\d{9}|50\\d{5}(?:\\d{2,3})?|[27-9]\\d{7,8}|(?:[34]\\d|6[0-35-9])\\d{6}|8\\d{4,6}";
var NI$1 = "(?:1800|[25-8]\\d{3})\\d{4}";
var NE$1 = "[027-9]\\d{7}";
var NG$1 = "2[0-24-9]\\d{8}|[78]\\d{10,13}|[7-9]\\d{9}|[1-9]\\d{7}|[124-7]\\d{6}";
var NU$1 = "(?:[4-7]|888\\d)\\d{3}";
var NF$1 = "[13]\\d{5}";
var MK$1 = "[2-578]\\d{7}";
var MP$1 = "[58]\\d{9}|(?:67|90)0\\d{7}";
var NO$1 = "(?:0|[2-9]\\d{3})\\d{4}";
var OM$1 = "(?:1505|[279]\\d{3}|500)\\d{4}|800\\d{5,6}";
var PK$1 = "122\\d{6}|[24-8]\\d{10,11}|9(?:[013-9]\\d{8,10}|2(?:[01]\\d\\d|2(?:[06-8]\\d|1[01]))\\d{7})|(?:[2-8]\\d{3}|92(?:[0-7]\\d|8[1-9]))\\d{6}|[24-9]\\d{8}|[89]\\d{7}";
var PW$1 = "(?:[24-8]\\d\\d|345|900)\\d{4}";
var PS$1 = "[2489]2\\d{6}|(?:1\\d|5)\\d{8}";
var PA$1 = "(?:00800|8\\d{3})\\d{6}|[68]\\d{7}|[1-57-9]\\d{6}";
var PG$1 = "(?:180|[78]\\d{3})\\d{4}|(?:[2-589]\\d|64)\\d{5}";
var PY$1 = "59\\d{4,6}|9\\d{5,10}|(?:[2-46-8]\\d|5[0-8])\\d{4,7}";
var PE$1 = "(?:[14-8]|9\\d)\\d{7}";
var PH$1 = "(?:[2-7]|9\\d)\\d{8}|2\\d{5}|(?:1800|8)\\d{7,9}";
var PN$1 = "";
var PL$1 = "(?:6|8\\d\\d)\\d{7}|[1-9]\\d{6}(?:\\d{2})?|[26]\\d{5}";
var PT$1 = "1693\\d{5}|(?:[26-9]\\d|30)\\d{7}";
var PR$1 = "(?:[589]\\d\\d|787)\\d{7}";
var QA$1 = "800\\d{4}|(?:2|800)\\d{6}|(?:0080|[3-7])\\d{7}";
var RE$1 = "(?:26|[689]\\d)\\d{7}";
var RO$1 = "(?:[236-8]\\d|90)\\d{7}|[23]\\d{5}";
var RU$1 = "8\\d{13}|[347-9]\\d{9}";
var RW$1 = "(?:06|[27]\\d\\d|[89]00)\\d{6}";
var BL$1 = "590\\d{6}|(?:69|80|9\\d)\\d{7}";
var SH$1 = "(?:[256]\\d|8)\\d{3}";
var KN$1 = "(?:[58]\\d\\d|900)\\d{7}";
var LC$1 = "(?:[58]\\d\\d|758|900)\\d{7}";
var MF$1 = "590\\d{6}|(?:69|80|9\\d)\\d{7}";
var PM$1 = "[45]\\d{5}|(?:708|80\\d)\\d{6}";
var VC$1 = "(?:[58]\\d\\d|784|900)\\d{7}";
var WS$1 = "(?:[2-6]|8\\d{5})\\d{4}|[78]\\d{6}|[68]\\d{5}";
var SM$1 = "(?:0549|[5-7]\\d)\\d{6}";
var ST$1 = "(?:22|9\\d)\\d{5}";
var SA$1 = "92\\d{7}|(?:[15]|8\\d)\\d{8}";
var SN$1 = "(?:[378]\\d|93)\\d{7}";
var RS$1 = "38[02-9]\\d{6,9}|6\\d{7,9}|90\\d{4,8}|38\\d{5,6}|(?:7\\d\\d|800)\\d{3,9}|(?:[12]\\d|3[0-79])\\d{5,10}";
var SC$1 = "800\\d{4}|(?:[249]\\d|64)\\d{5}";
var SL$1 = "(?:[237-9]\\d|66)\\d{6}";
var SG$1 = "(?:(?:1\\d|8)\\d\\d|7000)\\d{7}|[3689]\\d{7}";
var SX$1 = "7215\\d{6}|(?:[58]\\d\\d|900)\\d{7}";
var SK$1 = "[2-689]\\d{8}|[2-59]\\d{6}|[2-5]\\d{5}";
var SI$1 = "[1-7]\\d{7}|8\\d{4,7}|90\\d{4,6}";
var SB$1 = "[6-9]\\d{6}|[1-6]\\d{4}";
var SO$1 = "[346-9]\\d{8}|[12679]\\d{7}|[1-5]\\d{6}|[1348]\\d{5}";
var ZA$1 = "[1-79]\\d{8}|8\\d{4,9}";
var GS$1 = "";
var SS$1 = "[19]\\d{8}";
var ES$1 = "[5-9]\\d{8}";
var LK$1 = "[1-9]\\d{8}";
var SD$1 = "[19]\\d{8}";
var SR$1 = "(?:[2-5]|68|[78]\\d)\\d{5}";
var SJ$1 = "0\\d{4}|(?:[489]\\d|79)\\d{6}";
var SE$1 = "(?:[26]\\d\\d|9)\\d{9}|[1-9]\\d{8}|[1-689]\\d{7}|[1-4689]\\d{6}|2\\d{5}";
var CH$1 = "8\\d{11}|[2-9]\\d{8}";
var SY$1 = "[1-39]\\d{8}|[1-5]\\d{7}";
var TW$1 = "[2-689]\\d{8}|7\\d{9,10}|[2-8]\\d{7}|2\\d{6}";
var TJ$1 = "[0-57-9]\\d{8}";
var TZ$1 = "(?:[25-8]\\d|41|90)\\d{7}";
var TH$1 = "(?:001800|[2-57]|[689]\\d)\\d{7}|1\\d{7,9}";
var TL$1 = "7\\d{7}|(?:[2-47]\\d|[89]0)\\d{5}";
var TG$1 = "[279]\\d{7}";
var TK$1 = "[2-47]\\d{3,6}";
var TO$1 = "(?:0800|(?:[5-8]\\d\\d|999)\\d)\\d{3}|[2-8]\\d{4}";
var TT$1 = "(?:[58]\\d\\d|900)\\d{7}";
var TN$1 = "[2-57-9]\\d{7}";
var TR$1 = "4\\d{6}|8\\d{11,12}|(?:[2-58]\\d\\d|900)\\d{7}";
var TM$1 = "(?:[1-6]\\d|71)\\d{6}";
var TC$1 = "(?:[58]\\d\\d|649|900)\\d{7}";
var TV$1 = "(?:2|7\\d\\d|90)\\d{4}";
var UG$1 = "800\\d{6}|(?:[29]0|[347]\\d)\\d{7}";
var UA$1 = "[89]\\d{9}|[3-9]\\d{8}";
var AE$1 = "(?:[4-7]\\d|9[0-689])\\d{7}|800\\d{2,9}|[2-4679]\\d{7}";
var GB$1 = "[1-357-9]\\d{9}|[18]\\d{8}|8\\d{6}";
var UM$1 = "";
var US$1 = "[2-9]\\d{9}|3\\d{6}";
var UY$1 = "0004\\d{2,9}|[1249]\\d{7}|(?:[49]\\d|80)\\d{5}";
var UZ$1 = "(?:20|33|[5-79]\\d|88)\\d{7}";
var VU$1 = "[57-9]\\d{6}|(?:[238]\\d|48)\\d{3}";
var VE$1 = "[68]00\\d{7}|(?:[24]\\d|[59]0)\\d{8}";
var VN$1 = "[12]\\d{9}|[135-9]\\d{8}|[16]\\d{7}|[16-8]\\d{6}";
var VG$1 = "(?:284|[58]\\d\\d|900)\\d{7}";
var VI$1 = "[58]\\d{9}|(?:34|90)0\\d{7}";
var WF$1 = "(?:40|72)\\d{4}|8\\d{5}(?:\\d{3})?";
var EH$1 = "[5-8]\\d{8}";
var YE$1 = "(?:1|7\\d)\\d{7}|[1-7]\\d{6}";
var ZM$1 = "800\\d{6}|(?:21|63|[79]\\d)\\d{7}";
var ZW$1 = "2(?:[0-57-9]\\d{6,8}|6[0-24-9]\\d{6,7})|[38]\\d{9}|[35-8]\\d{8}|[3-6]\\d{7}|[1-689]\\d{6}|[1-3569]\\d{5}|[1356]\\d{4}";
var XK$1 = "2\\d{7,8}|3\\d{7,11}|(?:4\\d\\d|[89]00)\\d{5}";
var FW$1 = "^\\+590\\s\\d{2}\\s\\d{2}\\s\\d{2}\\s\\d{2}$";
var PHONE_REGEX_MAPPER = {
	AF: AF$1,
	AX: AX$1,
	AL: AL$1,
	DZ: DZ$1,
	AS: AS$1,
	AD: AD$1,
	AO: AO$1,
	AI: AI$1,
	AQ: AQ$1,
	AG: AG$1,
	AR: AR$1,
	AM: AM$1,
	AW: AW$1,
	AU: AU$1,
	AT: AT$1,
	AZ: AZ$1,
	BS: BS$1,
	BH: BH$1,
	BD: BD$1,
	BB: BB$1,
	BY: BY$1,
	BE: BE$1,
	BZ: BZ$1,
	BJ: BJ$1,
	BM: BM$1,
	BT: BT$1,
	BO: BO$1,
	BQ: BQ$1,
	BA: BA$1,
	BW: BW$1,
	BV: BV$1,
	BR: BR$1,
	IO: IO$1,
	BN: BN$1,
	BG: BG$1,
	BF: BF$1,
	BI: BI$1,
	CV: CV$1,
	KH: KH$1,
	CM: CM$1,
	CA: CA$1,
	KY: KY$1,
	CF: CF$1,
	TD: TD$1,
	CL: CL$1,
	CN: CN$1,
	CX: CX$1,
	CC: CC$1,
	CO: CO$1,
	KM: KM$1,
	CD: CD$1,
	CG: CG$1,
	CK: CK$1,
	CR: CR$1,
	CI: CI$1,
	HR: HR$1,
	CU: CU$1,
	CW: CW$1,
	CY: CY$1,
	CZ: CZ$1,
	DK: DK$1,
	DJ: DJ$1,
	DM: DM$1,
	DO: DO$1,
	EC: EC$1,
	EG: EG$1,
	SV: SV$1,
	GQ: GQ$1,
	ER: ER$1,
	EE: EE$1,
	SZ: SZ$1,
	ET: ET$1,
	FK: FK$1,
	FO: FO$1,
	FJ: FJ$1,
	FI: FI$1,
	FR: FR$1,
	GF: GF$1,
	PF: PF$1,
	TF: TF$1,
	GA: GA$1,
	GM: GM$1,
	GE: GE$1,
	DE: DE$1,
	GH: GH$1,
	GI: GI$1,
	GR: GR$1,
	GL: GL$1,
	GD: GD$1,
	GP: GP$1,
	GU: GU$1,
	GT: GT$1,
	GG: GG$1,
	GN: GN$1,
	GW: GW$1,
	GY: GY$1,
	HT: HT$1,
	HM: HM$1,
	VA: VA$1,
	HN: HN$1,
	HK: HK$1,
	HU: HU$1,
	IS: IS$1,
	IN: IN$1,
	ID: ID$1,
	IR: IR$1,
	IQ: IQ$1,
	IE: IE$1,
	IM: IM$1,
	IL: IL$1,
	IT: IT$1,
	JM: JM$1,
	JP: JP$1,
	JE: JE$1,
	JO: JO$1,
	KZ: KZ$1,
	KE: KE$1,
	KI: KI$1,
	KP: KP$1,
	KR: KR$1,
	KW: KW$1,
	KG: KG$1,
	LA: LA$1,
	LV: LV$1,
	LB: LB$1,
	LS: LS$1,
	LR: LR$1,
	LY: LY$1,
	LI: LI$1,
	LT: LT$1,
	LU: LU$1,
	MO: MO$1,
	MG: MG$1,
	MW: MW$1,
	MY: MY$1,
	MV: MV$1,
	ML: ML$1,
	MT: MT$1,
	MH: MH$1,
	MQ: MQ$1,
	MR: MR$1,
	MU: MU$1,
	YT: YT$1,
	MX: MX$1,
	FM: FM$1,
	MD: MD$1,
	MC: MC$1,
	MN: MN$1,
	ME: ME$1,
	MS: MS$1,
	MA: MA$1,
	MZ: MZ$1,
	MM: MM$1,
	NA: NA$1,
	NR: NR$1,
	NP: NP$1,
	NL: NL$1,
	NC: NC$1,
	NZ: NZ$1,
	NI: NI$1,
	NE: NE$1,
	NG: NG$1,
	NU: NU$1,
	NF: NF$1,
	MK: MK$1,
	MP: MP$1,
	NO: NO$1,
	OM: OM$1,
	PK: PK$1,
	PW: PW$1,
	PS: PS$1,
	PA: PA$1,
	PG: PG$1,
	PY: PY$1,
	PE: PE$1,
	PH: PH$1,
	PN: PN$1,
	PL: PL$1,
	PT: PT$1,
	PR: PR$1,
	QA: QA$1,
	RE: RE$1,
	RO: RO$1,
	RU: RU$1,
	RW: RW$1,
	BL: BL$1,
	SH: SH$1,
	KN: KN$1,
	LC: LC$1,
	MF: MF$1,
	PM: PM$1,
	VC: VC$1,
	WS: WS$1,
	SM: SM$1,
	ST: ST$1,
	SA: SA$1,
	SN: SN$1,
	RS: RS$1,
	SC: SC$1,
	SL: SL$1,
	SG: SG$1,
	SX: SX$1,
	SK: SK$1,
	SI: SI$1,
	SB: SB$1,
	SO: SO$1,
	ZA: ZA$1,
	GS: GS$1,
	SS: SS$1,
	ES: ES$1,
	LK: LK$1,
	SD: SD$1,
	SR: SR$1,
	SJ: SJ$1,
	SE: SE$1,
	CH: CH$1,
	SY: SY$1,
	TW: TW$1,
	TJ: TJ$1,
	TZ: TZ$1,
	TH: TH$1,
	TL: TL$1,
	TG: TG$1,
	TK: TK$1,
	TO: TO$1,
	TT: TT$1,
	TN: TN$1,
	TR: TR$1,
	TM: TM$1,
	TC: TC$1,
	TV: TV$1,
	UG: UG$1,
	UA: UA$1,
	AE: AE$1,
	GB: GB$1,
	UM: UM$1,
	US: US$1,
	UY: UY$1,
	UZ: UZ$1,
	VU: VU$1,
	VE: VE$1,
	VN: VN$1,
	VG: VG$1,
	VI: VI$1,
	WF: WF$1,
	EH: EH$1,
	YE: YE$1,
	ZM: ZM$1,
	ZW: ZW$1,
	XK: XK$1,
	FW: FW$1,
	"YT-UNF": "^(?:\\+262)?\\d{9}$",
	"BQ-BO": "",
	"BQ-SA": "",
	"BQ-SE": "",
	"GB-ENG": "",
	"GB-NIR": "",
	"GB-SCT": "",
	"GB-UKM": "",
	"GB-WLS": ""
};

var dial_code_to_country = {
	"1": [
		"US",
		"AG",
		"AI",
		"AS",
		"BB",
		"BM",
		"BS",
		"CA",
		"DM",
		"DO",
		"GD",
		"GU",
		"JM",
		"KN",
		"KY",
		"LC",
		"MP",
		"MS",
		"PR",
		"TC",
		"TT",
		"VC",
		"VG",
		"VI"
	],
	"7": [
		"RU",
		"KZ"
	],
	"20": [
		"EG"
	],
	"27": [
		"ZA"
	],
	"30": [
		"GR"
	],
	"31": [
		"NL"
	],
	"32": [
		"BE"
	],
	"33": [
		"FR"
	],
	"34": [
		"ES"
	],
	"36": [
		"HU"
	],
	"39": [
		"IT",
		"VA"
	],
	"40": [
		"RO"
	],
	"41": [
		"CH"
	],
	"43": [
		"AT"
	],
	"44": [
		"GB",
		"GB-ENG",
		"GB-NIR",
		"GB-SCT",
		"GB-UKM",
		"GB-WLS"
	],
	"45": [
		"DK"
	],
	"46": [
		"SE"
	],
	"47": [
		"NO"
	],
	"48": [
		"PL"
	],
	"49": [
		"DE"
	],
	"51": [
		"PE"
	],
	"52": [
		"MX"
	],
	"53": [
		"CU"
	],
	"54": [
		"AR"
	],
	"55": [
		"BR"
	],
	"56": [
		"CL"
	],
	"57": [
		"CO"
	],
	"58": [
		"VE"
	],
	"60": [
		"MY"
	],
	"61": [
		"AU"
	],
	"62": [
		"ID"
	],
	"63": [
		"PH"
	],
	"64": [
		"NZ"
	],
	"65": [
		"SG"
	],
	"66": [
		"TH"
	],
	"81": [
		"JP"
	],
	"82": [
		"KR"
	],
	"84": [
		"VN"
	],
	"86": [
		"CN"
	],
	"90": [
		"TR"
	],
	"91": [
		"IN"
	],
	"92": [
		"PK"
	],
	"93": [
		"AF"
	],
	"94": [
		"LK"
	],
	"95": [
		"MM"
	],
	"98": [
		"IR"
	],
	"211": [
		"SS"
	],
	"212": [
		"MA"
	],
	"213": [
		"DZ"
	],
	"216": [
		"TN"
	],
	"218": [
		"LY"
	],
	"220": [
		"GM"
	],
	"221": [
		"SN"
	],
	"222": [
		"MR"
	],
	"223": [
		"ML"
	],
	"224": [
		"GN"
	],
	"225": [
		"CI"
	],
	"226": [
		"BF"
	],
	"227": [
		"NE"
	],
	"228": [
		"TG"
	],
	"229": [
		"BJ"
	],
	"230": [
		"MU"
	],
	"231": [
		"LR"
	],
	"232": [
		"SL"
	],
	"233": [
		"GH"
	],
	"234": [
		"NG"
	],
	"235": [
		"TD"
	],
	"236": [
		"CF"
	],
	"237": [
		"CM"
	],
	"238": [
		"CV"
	],
	"239": [
		"ST"
	],
	"240": [
		"GQ"
	],
	"241": [
		"GA"
	],
	"242": [
		"CG"
	],
	"243": [
		"CD"
	],
	"244": [
		"AO"
	],
	"245": [
		"GW"
	],
	"248": [
		"SC"
	],
	"249": [
		"SD"
	],
	"250": [
		"RW"
	],
	"251": [
		"ET"
	],
	"252": [
		"SO"
	],
	"253": [
		"DJ"
	],
	"254": [
		"KE"
	],
	"255": [
		"TZ"
	],
	"256": [
		"UG"
	],
	"257": [
		"BI"
	],
	"258": [
		"MZ"
	],
	"260": [
		"ZM"
	],
	"261": [
		"MG"
	],
	"262": [
		"RE",
		"YT",
		"YT-UNF"
	],
	"263": [
		"ZW"
	],
	"264": [
		"NA"
	],
	"265": [
		"MW"
	],
	"266": [
		"LS"
	],
	"267": [
		"BW"
	],
	"268": [
		"SZ"
	],
	"269": [
		"KM"
	],
	"290": [
		"SH"
	],
	"291": [
		"ER"
	],
	"297": [
		"AW"
	],
	"298": [
		"FO"
	],
	"299": [
		"GL"
	],
	"350": [
		"GI"
	],
	"351": [
		"PT"
	],
	"352": [
		"LU"
	],
	"353": [
		"IE"
	],
	"354": [
		"IS"
	],
	"355": [
		"AL"
	],
	"356": [
		"MT"
	],
	"357": [
		"CY"
	],
	"358": [
		"FI"
	],
	"359": [
		"BG"
	],
	"370": [
		"LT"
	],
	"371": [
		"LV"
	],
	"372": [
		"EE"
	],
	"373": [
		"MD"
	],
	"374": [
		"AM"
	],
	"375": [
		"BY"
	],
	"376": [
		"AD"
	],
	"377": [
		"MC"
	],
	"378": [
		"SM"
	],
	"380": [
		"UA"
	],
	"381": [
		"RS"
	],
	"382": [
		"ME"
	],
	"383": [
		"XK"
	],
	"385": [
		"HR"
	],
	"386": [
		"SI"
	],
	"387": [
		"BA"
	],
	"389": [
		"MK"
	],
	"420": [
		"CZ"
	],
	"421": [
		"SK"
	],
	"423": [
		"LI"
	],
	"500": [
		"FK"
	],
	"501": [
		"BZ"
	],
	"502": [
		"GT"
	],
	"503": [
		"SV"
	],
	"504": [
		"HN"
	],
	"505": [
		"NI"
	],
	"506": [
		"CR"
	],
	"507": [
		"PA"
	],
	"509": [
		"HT"
	],
	"590": [
		"MF",
		"FW"
	],
	"591": [
		"BO"
	],
	"592": [
		"GY"
	],
	"593": [
		"EC"
	],
	"594": [
		"GF"
	],
	"595": [
		"PY"
	],
	"597": [
		"SR"
	],
	"598": [
		"UY"
	],
	"599": [
		"CW",
		"BQ",
		"BQ-BO",
		"BQ-SA",
		"BQ-SE"
	],
	"670": [
		"TL"
	],
	"673": [
		"BN"
	],
	"674": [
		"NR"
	],
	"675": [
		"PG"
	],
	"676": [
		"TO"
	],
	"677": [
		"SB"
	],
	"678": [
		"VU"
	],
	"679": [
		"FJ"
	],
	"680": [
		"PW"
	],
	"682": [
		"CK"
	],
	"683": [
		"NU"
	],
	"685": [
		"WS"
	],
	"686": [
		"KI"
	],
	"687": [
		"NC"
	],
	"688": [
		"TV"
	],
	"689": [
		"PF"
	],
	"691": [
		"FM"
	],
	"692": [
		"MH"
	],
	"850": [
		"KP"
	],
	"852": [
		"HK"
	],
	"853": [
		"MO"
	],
	"855": [
		"KH"
	],
	"856": [
		"LA"
	],
	"880": [
		"BD"
	],
	"886": [
		"TW"
	],
	"960": [
		"MV"
	],
	"961": [
		"LB"
	],
	"962": [
		"JO"
	],
	"963": [
		"SY"
	],
	"964": [
		"IQ"
	],
	"965": [
		"KW"
	],
	"966": [
		"SA"
	],
	"967": [
		"YE"
	],
	"968": [
		"OM"
	],
	"970": [
		"PS"
	],
	"971": [
		"AE"
	],
	"972": [
		"IL"
	],
	"973": [
		"BH"
	],
	"974": [
		"QA"
	],
	"975": [
		"BT"
	],
	"976": [
		"MN"
	],
	"977": [
		"NP"
	],
	"992": [
		"TJ"
	],
	"993": [
		"TM"
	],
	"994": [
		"AZ"
	],
	"995": [
		"GE"
	],
	"996": [
		"KG"
	],
	"998": [
		"UZ"
	]
};
var DIAL_CODE_MAPPER = {
	dial_code_to_country: dial_code_to_country
};

/**
 * Determines the country data (countryCode, dialCode) based on the provided phone number.
 * This function employs a multi-step approach to identify the country code:
 * - If the phone number starts with '+', it extracts the numeric characters
 *   and matches the leading digits with known dial codes mapped to countries.
 * - For matched dial codes, it further filters based on country-specific regex patterns
 *   to validate the phone number format for those countries.
 * - If the phone number doesn't start with '+', it returns empty strings as dialCode and countryCode
 *
 * @param phoneNumber The input phone number (string or number).
 * @returns The detected countryCode & dialCode or an empty strings in both if not found.
 */
const detectCountryAndDialCodeFromPhone = (phoneNumber) => {
    const regexMapper = PHONE_REGEX_MAPPER;
    // If the phone number starts with '+', extract numeric characters
    if (phoneNumber.toString().charAt(0) === '+') {
        const cleanedPhoneNumberWithoutPlusPrefix = phoneNumber
            .toString()
            .replace(/\D/g, '');
        const matchingCountries = [];
        const dialCodeMap = DIAL_CODE_MAPPER.dial_code_to_country;
        // Iterate through dial codes and check for matches with cleaned phone number
        for (const code in dialCodeMap) {
            if (cleanedPhoneNumberWithoutPlusPrefix.startsWith(code)) {
                matchingCountries.push(...dialCodeMap[code].map((item) => ({
                    countryCode: item,
                    dialCode: `+${code}`,
                })));
            }
        }
        // Filter matching countries based on phone number validation regex
        const matchedCountryCode = matchingCountries.find((country) => {
            const phoneNumberWithoutDialCode = String(phoneNumber).replace(country.dialCode, '');
            const regex = regexMapper[country.countryCode];
            if (regex &&
                matchesEntirely(phoneNumberWithoutDialCode, regex))
                return country;
            return undefined;
        });
        // Return the first matched country code, if any
        return (matchedCountryCode || {
            countryCode: '',
            dialCode: '',
        });
    }
    // Return empty string if no country code is detected
    return { countryCode: '', dialCode: '' };
};
const getPhoneNumberWithoutDialCode = (phoneNumber) => {
    const cleanedPhoneNumber = cleanPhoneNumber(String(phoneNumber));
    const { dialCode } = detectCountryAndDialCodeFromPhone(cleanedPhoneNumber);
    return String(cleanedPhoneNumber).replace(dialCode, '');
};
const cleanPhoneNumber = (phoneNumber) => {
    // Regular expression to match all characters except numbers and + sign at the start
    const regex = /[^0-9+]|(?!A)\+/g;
    // Replace matched characters with an empty string
    const cleanedPhoneNumber = phoneNumber.replace(regex, '');
    return phoneNumber[0] === '+' ? `+${cleanedPhoneNumber}` : cleanedPhoneNumber;
};
/**
 * Replaces the first `n` occurrences of 'x' in a source string with the first `n` characters from a replacement string.
 *
 * @param source {string} - The original string where replacements are to be made.
 * @param replacement {string} - The string from which replacement characters are taken.
 * @param n {number} - The number of 'x' characters to replace (unmasked digit count).
 * @returns {string} - The modified string after replacements.
 */
const suffixMasking = (source, replacement, n) => {
    // Convert the source string into an array of characters for easy manipulation
    const result = source.split('');
    let replaceIndex = 0;
    let replacementsDone = 0;
    // Iterate over the result array to replace 'x' with characters from the replacement string
    for (let i = 0; i < result.length && replacementsDone < n; i++) {
        if (result[i] === 'x' && replaceIndex < replacement.length) {
            result[i] = replacement[replaceIndex++];
            replacementsDone++;
        }
    }
    // Join the array back into a string and return the modified result
    return result.join('');
};
/**
 * Replaces the last `n` occurrences of 'x' in a source string with the last `n` characters from a replacement string.
 *
 * @param source {string} - The original string where replacements are to be made.
 * @param replacement {string} - The string from which replacement characters are taken.
 * @param n {number} - The number of 'x' characters to replace from the end of the source string  (unmasked digit count).
 * @returns {string} - The modified string after replacements.
 */
const prefixMasking = (source, replacement, n) => {
    // Convert the source string into an array of characters for easy manipulation
    const result = source.split('');
    let replaceIndex = replacement.length - 1;
    let replacementsDone = 0;
    // Iterate from the end of the source string
    for (let i = result.length - 1; i >= 0 && replacementsDone < n; i--) {
        if (result[i] === 'x' && replaceIndex >= 0) {
            result[i] = replacement[replaceIndex--];
            replacementsDone++;
        }
    }
    // Join the array back into a string and return the modified result
    return result.join('');
};
/**
 * Replaces every alternate digit of phone number with 'x' in phoneNumberWithoutDialCode.
 *
 * @param phoneNumberWithoutDialCode {number | string} - The original phone number without dial code where replacements are to be made.
 * @returns {string} - The modified string after replacements.
 */
const alternateMasking = (phoneNumberWithoutDialCode) => {
    return String(phoneNumberWithoutDialCode)
        .trim()
        .split('')
        .reduce((acc, char) => {
        if (/\d/.test(char)) {
            acc.numericCount % 2 !== 0
                ? acc.result.push('x')
                : acc.result.push(char);
            acc.numericCount++;
        }
        return acc;
    }, { result: [], numericCount: 0 })
        .result.join('');
};
const matchesEntirely = (text, regular_expression) => {
    text = text || '';
    return new RegExp('^(?:' + regular_expression + ')$').test(text);
};

// Validates whether a given phone number is valid based on the provided country code or auto-detects the country code and checks if the number matches the defined regex pattern for that country.
const isValidPhoneNumber = (phoneNumber, countryCode) => {
    // Clean the provided phoneNumber by removing non-numeric characters
    const cleanedPhoneNumber = cleanPhoneNumber(phoneNumber.toString());
    if (!cleanedPhoneNumber)
        return false;
    const regexMapper = PHONE_REGEX_MAPPER;
    const phoneInfo = detectCountryAndDialCodeFromPhone(cleanedPhoneNumber);
    // Detect or validate the country code
    countryCode = (countryCode && countryCode in regexMapper
        ? countryCode
        : phoneInfo.countryCode);
    // Return false if phoneNumber is empty
    if (!phoneNumber)
        return false;
    // Check if the countryCode exists in the PHONE_REGEX_MAPPER
    if (countryCode in regexMapper) {
        const phoneNumberWithoutDialCode = getPhoneNumberWithoutDialCode(cleanedPhoneNumber);
        // Fetch the regex pattern for the countryCode
        const regex = regexMapper[countryCode];
        // Test if the cleanedPhoneNumber matches the regex pattern
        return matchesEntirely(phoneNumberWithoutDialCode, regex);
    }
    // Return false if the countryCode is not supported
    return false;
};
var isValidPhoneNumber$1 = withErrorBoundary(isValidPhoneNumber);

var AF = "xx xxx xxxx";
var AX = "xxx xxx";
var AL = "xxx xx xxxx";
var DZ = "xxxx-xxxx-xxx";
var AS = "xxx-xxxx";
var AD = "xxx xxx";
var AO = "xx xxx xxxx";
var AI = "xxx-xxxx";
var AQ = "";
var AG = "xxx-xxxx";
var AR = "xxxx-xxxx";
var AM = "xx xx xx xx";
var AW = "xxx-xxxx";
var AU = "xxx xxx xxx";
var AT = "xxx xxxxxxxx";
var AZ = "xx xxx xx xx";
var BS = "xxx-xxxx";
var BH = "xxxx xxxx";
var BD = "xxxx-xxxxxx";
var BB = "xxx-xxxx";
var BY = "xx xxx-xx-xx";
var BE = "xxx xx xx xx";
var BZ = "xxx-xxxx";
var BJ = "xx xx xx xx";
var BM = "xxx-xxxx";
var BT = "x xxx xxx";
var BO = "xxxx-xxxx";
var BQ = "xxx xxxx";
var BA = "xx xxx-xxxx";
var BW = "xx xxxx xxxx";
var BV = "";
var BR = "xx xxxx-xxxx";
var IO = "xxx xxxx";
var BN = "xxxx-xxxx";
var BG = "xx xxx xxxx";
var BF = "xx xx xx xx";
var BI = "xx xx xx xx";
var CV = "xxx xxxx";
var KH = "xxx-xxx-xxx";
var CM = "xx xx xx xx";
var CA = "xxx-xxx-xxxx";
var KY = "xxx-xxxx";
var CF = "xx xx xx xx";
var TD = "xx xx xx xx";
var CL = "x xxxx xxxx";
var CN = "xxxx-xxxxxxx";
var CX = "xxx xxxx xxxx";
var CC = "xxx xxxx xxxx";
var CO = "xxxx-xxxxxxx";
var KM = "xx xx xx xx";
var CD = "xx xxx xxxx";
var CG = "xx xx xx xx";
var CK = "xx xxx";
var CR = "xxxx-xxxx";
var CI = "xx xx xx xx";
var HR = "xxx xxx xxxx";
var CU = "xxxx-xxxx";
var CW = "xxx xxxx";
var CY = "xx xxxxxx";
var CZ = "xxx xxx xxx";
var DK = "xx xx xx xx";
var DJ = "xx xx xx xx";
var DM = "xxx-xxxx";
var DO = "xxx-xxxxxxx";
var EC = "xx xxx xxxx";
var EG = "xx xxx xxxx";
var SV = "xxxx-xxxx";
var GQ = "xx xxx xxxx";
var ER = "x xxx xxxx";
var EE = "xxx xxxx";
var SZ = "xxx xx xxxx";
var ET = "xx xxx xxxx";
var FK = "xxxxx";
var FO = "xxx xxx";
var FJ = "xxxx xxxx";
var FI = "xx xxx xxxx";
var FR = "xx xx xx xx xx";
var GF = "xxx xx xx xx";
var PF = "xx xx xx xx";
var TF = "";
var GA = "xx xx xx xx";
var GM = "xxxx-xxxx";
var GE = "xxx xxx xxx";
var DE = "xxx xxxxxxxx";
var GH = "xxx xxx xxxx";
var GI = "xxxx xxxx";
var GR = "xx xxx xxxx";
var GL = "xx xx xx";
var GD = "xxx-xxxx";
var GP = "xxx xx xx xx";
var GU = "xxx-xxxx";
var GT = "xxxx-xxxx";
var GG = "xxxx xxxx";
var GN = "xx xx xx xx";
var GW = "xx xx xx xx";
var GY = "xxx-xxxx";
var HT = "xxx-xxxx";
var HM = "";
var VA = "xxx xxxx xxxx";
var HN = "xxxx-xxxx";
var HK = "xxxx xxxx";
var HU = "xxx xxx xxxx";
var IS = "xxx xxxx";
var IN = "xxxx xxxxxx";
var ID = "xxxx-xxxx-xxxx";
var IR = "xx xxxx xxxx";
var IQ = "xx xxx xxxx";
var IE = "xx xxx xxxx";
var IM = "xxxx xxxx";
var IL = "xxxx-xxx-xxx";
var IT = "xxx xxxx xxxx";
var JM = "xxx-xxxx";
var JP = "xx xxxx xxxx";
var JE = "xxxx xxxx";
var JO = "xx xxxx xxxx";
var KZ = "xxx-xxx-xx-xx";
var KE = "xxx xxxxxx";
var KI = "xx xxx";
var KP = "xx xxx xxxx";
var KR = "xx xxxx xxxx";
var KW = "xxx xx xxxx";
var KG = "xxx-xx-xx-xx";
var LA = "xxx xx xxxx";
var LV = "xxxx xxxx";
var LB = "xx xxx xxx";
var LS = "xxx xx xxxx";
var LR = "xxx-xxx-xxxx";
var LY = "xx xxxxx xxxx";
var LI = "xxx xx xx";
var LT = "xxx xxxxx";
var LU = "xxx xx xxx";
var MO = "xxxx xxxx";
var MG = "xx xx xx xx xx";
var MW = "xx xxxx xxxx";
var MY = "xx xxxxx xx";
var MV = "xxxxxx";
var ML = "xx xx xx xx";
var MT = "xx xx xx xx";
var MH = "xxx xxxx";
var MQ = "xxx xx xx xx";
var MR = "xx xx xx xx";
var MU = "xx xxxx xxxx";
var YT = "xxx xx xx xx";
var MX = "xxx-xxx-xxxx";
var FM = "xxx xxxx";
var MD = "xx xxxxxx";
var MC = "xx xx xx xx";
var MN = "xxx-xx-xxxx";
var ME = "xx xxxxxx";
var MS = "xxx-xxxx";
var MA = "xxxx-xxxxxx";
var MZ = "xx xxxxxxx";
var MM = "xx xxxxxx";
var NA = "xx xxxx xxxx";
var NR = "xxx xxxx";
var NP = "xxxx-xxxxxxx";
var NL = "xxx-xxxxxxx";
var NC = "xx xx xx";
var NZ = "xxx-xxxxxxx";
var NI = "xxxx-xxxx";
var NE = "xx xx xx xx";
var NG = "xxx xxx xxxx";
var NU = "xxxx";
var NF = "x xxxx";
var MK = "xx xx xx xx";
var MP = "xxx-xxxx";
var NO = "xxxx xxxx";
var OM = "xxxx-xxxx";
var PK = "xxx-xxxxxxx";
var PW = "xxx xxxx";
var PS = "xxxx-xxxxxxx";
var PA = "xxx-xxxx";
var PG = "xxx-xxxxxx";
var PY = "xxx-xxxxxx";
var PE = "xxx-xxx-xxx";
var PH = "xxx-xxxx";
var PN = "";
var PL = "xxx xxx xxx";
var PT = "xxx xxx xxx";
var PR = "xxx-xxx-xxxx";
var QA = "xxxx xxxx";
var RE = "xxx xx xx xx";
var RO = "xxx xxx xxxx";
var RU = "xxx xxx-xx-xx";
var RW = "xxx xxxxxx";
var BL = "xxx xx xx xx";
var SH = "xxxx";
var KN = "xxx-xxxx";
var LC = "xxx-xxxx";
var MF = "xxx xx xx xx";
var PM = "xxx xxxx";
var VC = "xxx-xxxx";
var WS = "xx xxxxx";
var SM = "xxxxx xxxxx";
var ST = "xx xxx xx";
var SA = "xxx-xxxxxxx";
var SN = "xx xxx xx xx";
var RS = "xxx xxxxx";
var SC = "xx xxxxx";
var SL = "xxx-xxxxxx";
var SG = "xxxx xxxx";
var SX = "xxx-xxxx";
var SK = "xxx xxx xxx";
var SI = "xx xxxxxx";
var SB = "xxxxx";
var SO = "xxx xxxxxxx";
var ZA = "xxx-xxx-xxxx";
var GS = "";
var SS = "xxx xxxx xxx";
var ES = "xxx xxx xxx";
var LK = "xx xxx xxxx";
var SD = "xx xxx xxxx";
var SR = "xxx-xxxx";
var SJ = "xxx xx xxx";
var SE = "xxx-xxx xx xx";
var CH = "xxx xxx xxx";
var SY = "xx xxxx xxxx";
var TW = "xxxx-xxxxxx";
var TJ = "xxx xx xx xx";
var TZ = "xxx xxx xxxx";
var TH = "xxx-xxxxxxx";
var TL = "xxx-xxxxxxx";
var TG = "xx xx xx xx";
var TK = "xxxx";
var TO = "xxxxx";
var TT = "xxx-xxxx";
var TN = "xx xxxxxx";
var TR = "xxx xxx xx xx";
var TM = "x xxx xxx";
var TC = "xxx-xxxx";
var TV = "xxxxx";
var UG = "xxx xxxxxxx";
var UA = "xx xxx xx xx";
var AE = "xx xxx xxxx";
var GB = "xxxx xxx xxx";
var UM = "";
var US = "xxx-xxx-xxxx";
var UY = "xxx-xxxxx";
var UZ = "xxx-xxx-xx-xx";
var VU = "xx xxxxx";
var VE = "xxxx-xxx-xxxx";
var VN = "xxxx-xxxxxxx";
var VG = "xxx-xxxx";
var VI = "xxx-xxxx";
var WF = "xx xxxx";
var EH = "xx xx xx xx";
var YE = "xxxx-xxxx";
var ZM = "xxx-xxxxxxx";
var ZW = "xx xxx xxxx";
var XK = "xxx xxx xxx";
var FW = "xxx xx xx xx";
var PHONE_FORMATTER_MAPPER = {
	AF: AF,
	AX: AX,
	AL: AL,
	DZ: DZ,
	AS: AS,
	AD: AD,
	AO: AO,
	AI: AI,
	AQ: AQ,
	AG: AG,
	AR: AR,
	AM: AM,
	AW: AW,
	AU: AU,
	AT: AT,
	AZ: AZ,
	BS: BS,
	BH: BH,
	BD: BD,
	BB: BB,
	BY: BY,
	BE: BE,
	BZ: BZ,
	BJ: BJ,
	BM: BM,
	BT: BT,
	BO: BO,
	BQ: BQ,
	BA: BA,
	BW: BW,
	BV: BV,
	BR: BR,
	IO: IO,
	BN: BN,
	BG: BG,
	BF: BF,
	BI: BI,
	CV: CV,
	KH: KH,
	CM: CM,
	CA: CA,
	KY: KY,
	CF: CF,
	TD: TD,
	CL: CL,
	CN: CN,
	CX: CX,
	CC: CC,
	CO: CO,
	KM: KM,
	CD: CD,
	CG: CG,
	CK: CK,
	CR: CR,
	CI: CI,
	HR: HR,
	CU: CU,
	CW: CW,
	CY: CY,
	CZ: CZ,
	DK: DK,
	DJ: DJ,
	DM: DM,
	DO: DO,
	EC: EC,
	EG: EG,
	SV: SV,
	GQ: GQ,
	ER: ER,
	EE: EE,
	SZ: SZ,
	ET: ET,
	FK: FK,
	FO: FO,
	FJ: FJ,
	FI: FI,
	FR: FR,
	GF: GF,
	PF: PF,
	TF: TF,
	GA: GA,
	GM: GM,
	GE: GE,
	DE: DE,
	GH: GH,
	GI: GI,
	GR: GR,
	GL: GL,
	GD: GD,
	GP: GP,
	GU: GU,
	GT: GT,
	GG: GG,
	GN: GN,
	GW: GW,
	GY: GY,
	HT: HT,
	HM: HM,
	VA: VA,
	HN: HN,
	HK: HK,
	HU: HU,
	IS: IS,
	IN: IN,
	ID: ID,
	IR: IR,
	IQ: IQ,
	IE: IE,
	IM: IM,
	IL: IL,
	IT: IT,
	JM: JM,
	JP: JP,
	JE: JE,
	JO: JO,
	KZ: KZ,
	KE: KE,
	KI: KI,
	KP: KP,
	KR: KR,
	KW: KW,
	KG: KG,
	LA: LA,
	LV: LV,
	LB: LB,
	LS: LS,
	LR: LR,
	LY: LY,
	LI: LI,
	LT: LT,
	LU: LU,
	MO: MO,
	MG: MG,
	MW: MW,
	MY: MY,
	MV: MV,
	ML: ML,
	MT: MT,
	MH: MH,
	MQ: MQ,
	MR: MR,
	MU: MU,
	YT: YT,
	MX: MX,
	FM: FM,
	MD: MD,
	MC: MC,
	MN: MN,
	ME: ME,
	MS: MS,
	MA: MA,
	MZ: MZ,
	MM: MM,
	NA: NA,
	NR: NR,
	NP: NP,
	NL: NL,
	NC: NC,
	NZ: NZ,
	NI: NI,
	NE: NE,
	NG: NG,
	NU: NU,
	NF: NF,
	MK: MK,
	MP: MP,
	NO: NO,
	OM: OM,
	PK: PK,
	PW: PW,
	PS: PS,
	PA: PA,
	PG: PG,
	PY: PY,
	PE: PE,
	PH: PH,
	PN: PN,
	PL: PL,
	PT: PT,
	PR: PR,
	QA: QA,
	RE: RE,
	RO: RO,
	RU: RU,
	RW: RW,
	BL: BL,
	SH: SH,
	KN: KN,
	LC: LC,
	MF: MF,
	PM: PM,
	VC: VC,
	WS: WS,
	SM: SM,
	ST: ST,
	SA: SA,
	SN: SN,
	RS: RS,
	SC: SC,
	SL: SL,
	SG: SG,
	SX: SX,
	SK: SK,
	SI: SI,
	SB: SB,
	SO: SO,
	ZA: ZA,
	GS: GS,
	SS: SS,
	ES: ES,
	LK: LK,
	SD: SD,
	SR: SR,
	SJ: SJ,
	SE: SE,
	CH: CH,
	SY: SY,
	TW: TW,
	TJ: TJ,
	TZ: TZ,
	TH: TH,
	TL: TL,
	TG: TG,
	TK: TK,
	TO: TO,
	TT: TT,
	TN: TN,
	TR: TR,
	TM: TM,
	TC: TC,
	TV: TV,
	UG: UG,
	UA: UA,
	AE: AE,
	GB: GB,
	UM: UM,
	US: US,
	UY: UY,
	UZ: UZ,
	VU: VU,
	VE: VE,
	VN: VN,
	VG: VG,
	VI: VI,
	WF: WF,
	EH: EH,
	YE: YE,
	ZM: ZM,
	ZW: ZW,
	XK: XK,
	FW: FW,
	"YT-UNF": "xxx xx xx xx",
	"BQ-BO": "",
	"BQ-SA": "",
	"BQ-SE": "",
	"GB-ENG": "",
	"GB-NIR": "",
	"GB-SCT": "",
	"GB-UKM": "",
	"GB-WLS": ""
};

// Formats a provided phone number according to the predefined format for a specific country code, or auto-detects the country code and formats the number accordingly.
const formatPhoneNumber = (phoneNumber, countryCode) => {
    // Throw errors if phoneNumber is invalid
    if (!phoneNumber)
        throw new Error(`Parameter 'phoneNumber' is invalid! The received value was: ${phoneNumber}. Please ensure you provide a valid phone number.`);
    // Convert phoneNumber to string and clean it by removing non-numeric characters
    phoneNumber = phoneNumber.toString();
    phoneNumber = cleanPhoneNumber(phoneNumber);
    const formatterMap = PHONE_FORMATTER_MAPPER;
    // Detect or validate the country code
    countryCode = (countryCode && countryCode in formatterMap
        ? countryCode
        : detectCountryAndDialCodeFromPhone(phoneNumber).countryCode);
    // Fetch the pattern for the countryCode from the PHONE_FORMATTER_MAPPER
    const pattern = formatterMap[countryCode];
    if (!pattern)
        return phoneNumber;
    // Count the number of 'x' characters in the format pattern
    let charCountInFormatterPattern = 0;
    for (let i = 0; i < pattern.length; i++) {
        if (pattern[i] === 'x') {
            charCountInFormatterPattern++;
        }
    }
    // Calculate the difference between phoneNumber length and 'x' characters count in pattern
    const diff = phoneNumber.length - charCountInFormatterPattern;
    // Extract the phoneNumber without the prefix
    const phoneNumberWithoutPrefix = phoneNumber.slice(diff);
    const formattedNumber = [];
    let numberIndex = 0;
    // Loop through the pattern to format the phoneNumber
    for (let i = 0; i < pattern.length; i++) {
        const patternChar = pattern[i];
        if (patternChar === 'x') {
            // Insert phoneNumber digits at 'x' positions
            if (numberIndex < phoneNumberWithoutPrefix.length) {
                formattedNumber.push(phoneNumberWithoutPrefix[numberIndex]);
                numberIndex++;
            }
        }
        else {
            // Insert non-digit characters from the pattern
            formattedNumber.push(patternChar);
        }
    }
    // Join the formattedNumber array to create the formattedPhoneNumber without prefix
    const formattedPhoneNumberWithoutPrefix = formattedNumber.join('');
    // Combine the prefix and formattedPhoneNumberWithoutPrefix
    const formattedPhoneNumberWithPrefix = phoneNumber.slice(0, diff) + ' ' + formattedPhoneNumberWithoutPrefix;
    // Return the formattedPhoneNumber with prefix after trimming whitespace
    return formattedPhoneNumberWithPrefix.trim();
};
var formatPhoneNumber$1 = withErrorBoundary(formatPhoneNumber);

// Parses a given phone number, identifies its country code (if not provided), and returns an object with details including the country code, formatted phone number, dial code, and format template.
const parsePhoneNumber = (phoneNumber, country) => {
    // Throw errors if phoneNumber is invalid
    if (!phoneNumber)
        throw new Error(`Parameter 'phoneNumber' is invalid! The received value was: ${phoneNumber}. Please ensure you provide a valid phone number.`);
    // Clean the phoneNumber by removing non-numeric characters
    phoneNumber = phoneNumber.toString();
    phoneNumber = cleanPhoneNumber(phoneNumber);
    const countryData = detectCountryAndDialCodeFromPhone(phoneNumber);
    const formatterMap = PHONE_FORMATTER_MAPPER;
    // Detect or validate the country code
    const countryCode = (country && country in formatterMap ? country : countryData.countryCode);
    const dialCode = countryData.dialCode;
    // Format the phone number using the detected/validated country code
    const formattedPhoneNumber = formatPhoneNumber$1(phoneNumber, countryCode);
    // Fetch the pattern associated with the countryCode from the PHONE_FORMATTER_MAPPER
    const pattern = formatterMap[countryCode];
    if (!pattern)
        return {
            countryCode,
            dialCode,
            formattedPhoneNumber: phoneNumber,
            formatTemplate: '',
            phoneNumber,
        };
    // Count the number of 'x' characters in the format pattern
    let charCountInFormatterPattern = 0;
    for (let i = 0; i < pattern.length; i++) {
        if (pattern[i] === 'x') {
            charCountInFormatterPattern++;
        }
    }
    // Calculate the difference between phoneNumber length and 'x' characters count in pattern
    const diff = phoneNumber.length - charCountInFormatterPattern;
    // Obtain the format template associated with the countryCode
    const formatTemplate = formatterMap[countryCode];
    // Return the parsed phone number information
    return {
        phoneNumber: phoneNumber.slice(diff),
        countryCode,
        dialCode,
        formattedPhoneNumber: pattern ? formattedPhoneNumber : phoneNumber,
        formatTemplate: formatTemplate || '',
    };
};
var parsePhoneNumber$1 = withErrorBoundary(parsePhoneNumber);

/**
 * Retrieves a mapping of country codes to their respective international dial codes.
 * @returns {Object} An object where each key is a country code (e.g., 'US', 'CA') and its value is the corresponding dial code (e.g., '+1' for 'US' and 'CA').
 */
const getDialCodes = () => {
    const countryDialCode = {};
    for (const [dialCode, countryCodes] of Object.entries(DIAL_CODE_MAPPER.dial_code_to_country)) {
        countryCodes.forEach((countryCode) => {
            countryDialCode[countryCode] = `+${Number(dialCode)}`;
        });
    }
    return countryDialCode;
};
var getDialCodes$1 = withErrorBoundary(getDialCodes);

/**
 * Retrieves the dial code for a specified country code.
 *
 * @param countryCode The country code for which the dial code is to be retrieved.
 *                    It must be a key of the object returned by the `getDialCodes` function.
 * @returns The corresponding dial code as a string.
 * @throws An error if the provided country code is not found in the dial code mapping.
 */
const getDialCodeByCountryCode = (countryCode) => {
    // Get the mapping of all country codes to their respective dial codes
    const dialCodeForAllCountries = getDialCodes$1();
    /** Check if the provided country code exists in the mapping.
     * Return the corresponding dial code if the country code is valid.
     * Throw an error if the country code is not found in the mapping
     * */
    if (countryCode in dialCodeForAllCountries)
        return dialCodeForAllCountries[countryCode];
    else
        throw new Error(`The provided country code is invalid. The received value was: ${countryCode}. Please ensure you pass a valid country code. Check valid country codes here: https://github.com/razorpay/i18nify/blob/master/i18nify-data/country/metadata/data.json`);
};
var getDialCodeByCountryCode$1 = withErrorBoundary(getDialCodeByCountryCode);

exports.MaskingStyle = void 0;
(function (MaskingStyle) {
    MaskingStyle["Full"] = "full";
    MaskingStyle["Prefix"] = "prefix";
    MaskingStyle["Suffix"] = "suffix";
    MaskingStyle["Alternate"] = "alternate";
})(exports.MaskingStyle || (exports.MaskingStyle = {}));

/**
 * Generates a masked phone number based on provided options.
 * This function handles the complexity of different phone number formats and
 * masking preferences such as complete masking or partial masking of digits.
 *
 * @param {GetMaskedPhoneNumberOptions} options - Options for generating the masked phone number.
 * @param {CountryCodeType} options.countryCode - The country code associated with the phone number.
 * @param {boolean} options.withDialCode - Determines if the dial code should be included in the masked number.
 * @param {string} options.phoneNumber - The actual phone number to mask.
 * @param {MaskingOptions} options.maskingOptions - Options to specify how the masking should be performed.
 * @returns {string} The masked phone number formatted as per the specified options.
 * @throws {Error} Throws an error if both countryCode and phoneNumber are empty or if other input validations fail.
 */
const getMaskedPhoneNumber = ({ countryCode, withDialCode = true, phoneNumber, maskingOptions = {}, }) => {
    const { maskingStyle = exports.MaskingStyle.Full, maskedDigitsCount = 0, maskingChar = 'x', } = maskingOptions;
    if (!countryCode && !phoneNumber) {
        throw new Error(`Either 'countryCode' or 'phoneNumber' is mandatory. Please provide a valid 'countryCode' or 'phoneNumber'. Check valid country codes here: https://github.com/razorpay/i18nify/blob/master/i18nify-data/country/metadata/data.json`);
    }
    let maskedContactNumber;
    let dialCode;
    if (phoneNumber) {
        // Clean the phone number to remove any non-numeric characters, except the leading '+'
        let updatedPhoneNumber = phoneNumber;
        updatedPhoneNumber = updatedPhoneNumber.toString();
        updatedPhoneNumber = cleanPhoneNumber(updatedPhoneNumber);
        // Detect the country code and dial code from the cleaned phone number
        const countryData = detectCountryAndDialCodeFromPhone(updatedPhoneNumber);
        const updatedCountryCode = countryCode || countryData.countryCode;
        try {
            dialCode = getDialCodeByCountryCode$1(updatedCountryCode);
        }
        catch (error) {
            dialCode = countryData.dialCode;
        }
        // Extract the phone number without dial code
        const phoneNumberWithoutDialCode = updatedPhoneNumber[0] === '+'
            ? updatedPhoneNumber.slice(dialCode.toString().length)
            : updatedPhoneNumber;
        // Get the phone number formatting template based on the country code
        const formattingTemplate = PHONE_FORMATTER_MAPPER[updatedCountryCode] ||
            phoneNumber.replace(/\d/g, 'x');
        switch (maskingStyle) {
            case exports.MaskingStyle.Alternate:
                // Example: 7394926646 --> 7x9x9x6x4x
                maskedContactNumber = alternateMasking(phoneNumberWithoutDialCode);
                break;
            case exports.MaskingStyle.Prefix:
                // Example: 7394926646 --> xxxx 926646
                maskedContactNumber = prefixMasking(formattingTemplate, String(phoneNumberWithoutDialCode), phoneNumberWithoutDialCode.length - maskedDigitsCount);
                break;
            case exports.MaskingStyle.Suffix:
                // Example: 7394926646 --> 7494 92xxxx
                maskedContactNumber = suffixMasking(formattingTemplate, String(phoneNumberWithoutDialCode), phoneNumberWithoutDialCode.length - maskedDigitsCount);
                break;
            default: // Full Masking Condition
                maskedContactNumber = formattingTemplate;
        }
    }
    else {
        // Retrieve the phone number formatting template using the country code
        maskedContactNumber = PHONE_FORMATTER_MAPPER[countryCode];
        if (!maskedContactNumber) {
            throw new Error(`Parameter 'countryCode' is invalid. The received value was: ${countryCode}. Check valid country codes here: https://github.com/razorpay/i18nify/blob/master/i18nify-data/country/metadata/data.json`);
        }
        dialCode = getDialCodeByCountryCode$1(countryCode);
    }
    // Include the dial code in the masked phone number if requested
    if (withDialCode) {
        return `${dialCode} ${maskedContactNumber.replace(/x/g, maskingChar)}`.trim();
    }
    else {
        return maskedContactNumber.trim().replace(/x/g, maskingChar);
    }
};
var getMaskedPhoneNumber$1 = withErrorBoundary(getMaskedPhoneNumber);

function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}

function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from the TC39 Temporal proposal.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $2b4dce13dd5a17fa$export$842a2cf37af977e1(amount, numerator) {
    return amount - numerator * Math.floor(amount / numerator);
}


const $3b62074eb05584b2$var$EPOCH = 1721426; // 001/01/03 Julian C.E.
function $3b62074eb05584b2$export$f297eb839006d339(era, year, month, day) {
    year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year);
    let y1 = year - 1;
    let monthOffset = -2;
    if (month <= 2) monthOffset = 0;
    else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) monthOffset = -1;
    return $3b62074eb05584b2$var$EPOCH - 1 + 365 * y1 + Math.floor(y1 / 4) - Math.floor(y1 / 100) + Math.floor(y1 / 400) + Math.floor((367 * month - 362) / 12 + monthOffset + day);
}
function $3b62074eb05584b2$export$553d7fa8e3805fc0(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year) {
    return era === "BC" ? 1 - year : year;
}
function $3b62074eb05584b2$export$4475b7e617eb123c(year) {
    let era = "AD";
    if (year <= 0) {
        era = "BC";
        year = 1 - year;
    }
    return [
        era,
        year
    ];
}
const $3b62074eb05584b2$var$daysInMonth = {
    standard: [
        31,
        28,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
    ],
    leapyear: [
        31,
        29,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
    ]
};
class $3b62074eb05584b2$export$80ee6245ec4f29ec {
    fromJulianDay(jd) {
        let jd0 = jd;
        let depoch = jd0 - $3b62074eb05584b2$var$EPOCH;
        let quadricent = Math.floor(depoch / 146097);
        let dqc = ($2b4dce13dd5a17fa$export$842a2cf37af977e1)(depoch, 146097);
        let cent = Math.floor(dqc / 36524);
        let dcent = ($2b4dce13dd5a17fa$export$842a2cf37af977e1)(dqc, 36524);
        let quad = Math.floor(dcent / 1461);
        let dquad = ($2b4dce13dd5a17fa$export$842a2cf37af977e1)(dcent, 1461);
        let yindex = Math.floor(dquad / 365);
        let extendedYear = quadricent * 400 + cent * 100 + quad * 4 + yindex + (cent !== 4 && yindex !== 4 ? 1 : 0);
        let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c(extendedYear);
        let yearDay = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, 1, 1);
        let leapAdj = 2;
        if (jd0 < $3b62074eb05584b2$export$f297eb839006d339(era, year, 3, 1)) leapAdj = 0;
        else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) leapAdj = 1;
        let month = Math.floor(((yearDay + leapAdj) * 12 + 373) / 367);
        let day = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, month, 1) + 1;
        return new ($35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, month, day);
    }
    toJulianDay(date) {
        return $3b62074eb05584b2$export$f297eb839006d339(date.era, date.year, date.month, date.day);
    }
    getDaysInMonth(date) {
        return $3b62074eb05584b2$var$daysInMonth[$3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? "leapyear" : "standard"][date.month - 1];
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getMonthsInYear(date) {
        return 12;
    }
    getDaysInYear(date) {
        return $3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? 366 : 365;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getYearsInEra(date) {
        return 9999;
    }
    getEras() {
        return [
            "BC",
            "AD"
        ];
    }
    isInverseEra(date) {
        return date.era === "BC";
    }
    balanceDate(date) {
        if (date.year <= 0) {
            date.era = date.era === "BC" ? "AD" : "BC";
            date.year = 1 - date.year;
        }
    }
    constructor(){
        this.identifier = "gregory";
    }
}
function $14e0f24ef4ac5c92$export$68781ddf31c0090f(a, b) {
    return a.calendar.toJulianDay(a) - b.calendar.toJulianDay(b);
}
function $14e0f24ef4ac5c92$export$c19a80a9721b80f6(a, b) {
    return $14e0f24ef4ac5c92$var$timeToMs(a) - $14e0f24ef4ac5c92$var$timeToMs(b);
}
function $14e0f24ef4ac5c92$var$timeToMs(a) {
    return a.hour * 3600000 + a.minute * 60000 + a.second * 1000 + a.millisecond;
}
let $14e0f24ef4ac5c92$var$localTimeZone = null;
function $14e0f24ef4ac5c92$export$aa8b41735afcabd2() {
    // TODO: invalidate this somehow?
    if ($14e0f24ef4ac5c92$var$localTimeZone == null) $14e0f24ef4ac5c92$var$localTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;
    return $14e0f24ef4ac5c92$var$localTimeZone;
}


function $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) {
    date = $11d87f3f76e88657$export$b4a036af3fc0b032(date, new ($3b62074eb05584b2$export$80ee6245ec4f29ec)());
    let year = ($3b62074eb05584b2$export$c36e0ecb2d4fa69d)(date.era, date.year);
    return $11d87f3f76e88657$var$epochFromParts(year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);
}
function $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, millisecond) {
    // Note: Date.UTC() interprets one and two-digit years as being in the
    // 20th century, so don't use it
    let date = new Date();
    date.setUTCHours(hour, minute, second, millisecond);
    date.setUTCFullYear(year, month - 1, day);
    return date.getTime();
}
function $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone) {
    // Fast path for UTC.
    if (timeZone === "UTC") return 0;
    // Fast path: for local timezone after 1970, use native Date.
    if (ms > 0 && timeZone === ($14e0f24ef4ac5c92$export$aa8b41735afcabd2)()) return new Date(ms).getTimezoneOffset() * -60000;
    let { year: year, month: month, day: day, hour: hour, minute: minute, second: second } = $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone);
    let utc = $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, 0);
    return utc - Math.floor(ms / 1000) * 1000;
}
const $11d87f3f76e88657$var$formattersByTimeZone = new Map();
function $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone) {
    let formatter = $11d87f3f76e88657$var$formattersByTimeZone.get(timeZone);
    if (!formatter) {
        formatter = new Intl.DateTimeFormat("en-US", {
            timeZone: timeZone,
            hour12: false,
            era: "short",
            year: "numeric",
            month: "numeric",
            day: "numeric",
            hour: "numeric",
            minute: "numeric",
            second: "numeric"
        });
        $11d87f3f76e88657$var$formattersByTimeZone.set(timeZone, formatter);
    }
    let parts = formatter.formatToParts(new Date(ms));
    let namedParts = {};
    for (let part of parts)if (part.type !== "literal") namedParts[part.type] = part.value;
    return {
        // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
        year: namedParts.era === "BC" || namedParts.era === "B" ? -namedParts.year + 1 : +namedParts.year,
        month: +namedParts.month,
        day: +namedParts.day,
        hour: namedParts.hour === "24" ? 0 : +namedParts.hour,
        minute: +namedParts.minute,
        second: +namedParts.second
    };
}
const $11d87f3f76e88657$var$DAYMILLIS = 86400000;
function $11d87f3f76e88657$var$getValidWallTimes(date, timeZone, earlier, later) {
    let found = earlier === later ? [
        earlier
    ] : [
        earlier,
        later
    ];
    return found.filter((absolute)=>$11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute));
}
function $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute) {
    let parts = $11d87f3f76e88657$var$getTimeZoneParts(absolute, timeZone);
    return date.year === parts.year && date.month === parts.month && date.day === parts.day && date.hour === parts.hour && date.minute === parts.minute && date.second === parts.second;
}
function $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation = "compatible") {
    let dateTime = $11d87f3f76e88657$export$b21e0b124e224484(date);
    // Fast path: if the time zone is UTC, use native Date.
    if (timeZone === "UTC") return $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
    // Fast path: if the time zone is the local timezone and disambiguation is compatible, use native Date.
    if (timeZone === ($14e0f24ef4ac5c92$export$aa8b41735afcabd2)() && disambiguation === "compatible") {
        dateTime = $11d87f3f76e88657$export$b4a036af3fc0b032(dateTime, new ($3b62074eb05584b2$export$80ee6245ec4f29ec)());
        // Don't use Date constructor here because two-digit years are interpreted in the 20th century.
        let date = new Date();
        let year = ($3b62074eb05584b2$export$c36e0ecb2d4fa69d)(dateTime.era, dateTime.year);
        date.setFullYear(year, dateTime.month - 1, dateTime.day);
        date.setHours(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);
        return date.getTime();
    }
    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
    let offsetBefore = $11d87f3f76e88657$export$59c99f3515d3493f(ms - $11d87f3f76e88657$var$DAYMILLIS, timeZone);
    let offsetAfter = $11d87f3f76e88657$export$59c99f3515d3493f(ms + $11d87f3f76e88657$var$DAYMILLIS, timeZone);
    let valid = $11d87f3f76e88657$var$getValidWallTimes(dateTime, timeZone, ms - offsetBefore, ms - offsetAfter);
    if (valid.length === 1) return valid[0];
    if (valid.length > 1) switch(disambiguation){
        // 'compatible' means 'earlier' for "fall back" transitions
        case "compatible":
        case "earlier":
            return valid[0];
        case "later":
            return valid[valid.length - 1];
        case "reject":
            throw new RangeError("Multiple possible absolute times found");
    }
    switch(disambiguation){
        case "earlier":
            return Math.min(ms - offsetBefore, ms - offsetAfter);
        // 'compatible' means 'later' for "spring forward" transitions
        case "compatible":
        case "later":
            return Math.max(ms - offsetBefore, ms - offsetAfter);
        case "reject":
            throw new RangeError("No such absolute time found");
    }
}
function $11d87f3f76e88657$export$e67a095c620b86fe(dateTime, timeZone, disambiguation = "compatible") {
    return new Date($11d87f3f76e88657$export$5107c82f94518f5c(dateTime, timeZone, disambiguation));
}
function $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone) {
    let offset = $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone);
    let date = new Date(ms + offset);
    let year = date.getUTCFullYear();
    let month = date.getUTCMonth() + 1;
    let day = date.getUTCDate();
    let hour = date.getUTCHours();
    let minute = date.getUTCMinutes();
    let second = date.getUTCSeconds();
    let millisecond = date.getUTCMilliseconds();
    return new ($35ea8db9cb2ccb90$export$d3b7288e7994edea)(year, month, day, timeZone, offset, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$b21e0b124e224484(date, time) {
    let hour = 0, minute = 0, second = 0, millisecond = 0;
    if ("timeZone" in date) ({ hour: hour, minute: minute, second: second, millisecond: millisecond } = date);
    else if ("hour" in date && !time) return date;
    if (time) ({ hour: hour, minute: minute, second: second, millisecond: millisecond } = time);
    return new ($35ea8db9cb2ccb90$export$ca871e8dbb80966f)(date.calendar, date.era, date.year, date.month, date.day, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$b4a036af3fc0b032(date, calendar) {
    if (date.calendar.identifier === calendar.identifier) return date;
    let calendarDate = calendar.fromJulianDay(date.calendar.toJulianDay(date));
    let copy = date.copy();
    copy.calendar = calendar;
    copy.era = calendarDate.era;
    copy.year = calendarDate.year;
    copy.month = calendarDate.month;
    copy.day = calendarDate.day;
    ($735220c2d4774dd3$export$c4e2ecac49351ef2)(copy);
    return copy;
}
function $11d87f3f76e88657$export$84c95a83c799e074(date, timeZone, disambiguation) {
    if (date instanceof ($35ea8db9cb2ccb90$export$d3b7288e7994edea)) {
        if (date.timeZone === timeZone) return date;
        return $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone);
    }
    let ms = $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation);
    return $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone);
}
function $11d87f3f76e88657$export$83aac07b4c37b25(date) {
    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
    return new Date(ms);
}
function $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone) {
    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
    return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone), date.calendar);
}



const $735220c2d4774dd3$var$ONE_HOUR = 3600000;
function $735220c2d4774dd3$export$e16d8520af44a096(date, duration) {
    let mutableDate = date.copy();
    let days = "hour" in mutableDate ? $735220c2d4774dd3$var$addTimeFields(mutableDate, duration) : 0;
    $735220c2d4774dd3$var$addYears(mutableDate, duration.years || 0);
    if (mutableDate.calendar.balanceYearMonth) mutableDate.calendar.balanceYearMonth(mutableDate, date);
    mutableDate.month += duration.months || 0;
    $735220c2d4774dd3$var$balanceYearMonth(mutableDate);
    $735220c2d4774dd3$var$constrainMonthDay(mutableDate);
    mutableDate.day += (duration.weeks || 0) * 7;
    mutableDate.day += duration.days || 0;
    mutableDate.day += days;
    $735220c2d4774dd3$var$balanceDay(mutableDate);
    if (mutableDate.calendar.balanceDate) mutableDate.calendar.balanceDate(mutableDate);
    // Constrain in case adding ended up with a date outside the valid range for the calendar system.
    // The behavior here is slightly different than when constraining in the `set` function in that
    // we adjust smaller fields to their minimum/maximum values rather than constraining each field
    // individually. This matches the general behavior of `add` vs `set` regarding how fields are balanced.
    if (mutableDate.year < 1) {
        mutableDate.year = 1;
        mutableDate.month = 1;
        mutableDate.day = 1;
    }
    let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);
    if (mutableDate.year > maxYear) {
        var _mutableDate_calendar_isInverseEra, _mutableDate_calendar;
        let isInverseEra = (_mutableDate_calendar_isInverseEra = (_mutableDate_calendar = mutableDate.calendar).isInverseEra) === null || _mutableDate_calendar_isInverseEra === void 0 ? void 0 : _mutableDate_calendar_isInverseEra.call(_mutableDate_calendar, mutableDate);
        mutableDate.year = maxYear;
        mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);
        mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);
    }
    if (mutableDate.month < 1) {
        mutableDate.month = 1;
        mutableDate.day = 1;
    }
    let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);
    if (mutableDate.month > maxMonth) {
        mutableDate.month = maxMonth;
        mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);
    }
    mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));
    return mutableDate;
}
function $735220c2d4774dd3$var$addYears(date, years) {
    var _date_calendar_isInverseEra, _date_calendar;
    if ((_date_calendar_isInverseEra = (_date_calendar = date.calendar).isInverseEra) === null || _date_calendar_isInverseEra === void 0 ? void 0 : _date_calendar_isInverseEra.call(_date_calendar, date)) years = -years;
    date.year += years;
}
function $735220c2d4774dd3$var$balanceYearMonth(date) {
    while(date.month < 1){
        $735220c2d4774dd3$var$addYears(date, -1);
        date.month += date.calendar.getMonthsInYear(date);
    }
    let monthsInYear = 0;
    while(date.month > (monthsInYear = date.calendar.getMonthsInYear(date))){
        date.month -= monthsInYear;
        $735220c2d4774dd3$var$addYears(date, 1);
    }
}
function $735220c2d4774dd3$var$balanceDay(date) {
    while(date.day < 1){
        date.month--;
        $735220c2d4774dd3$var$balanceYearMonth(date);
        date.day += date.calendar.getDaysInMonth(date);
    }
    while(date.day > date.calendar.getDaysInMonth(date)){
        date.day -= date.calendar.getDaysInMonth(date);
        date.month++;
        $735220c2d4774dd3$var$balanceYearMonth(date);
    }
}
function $735220c2d4774dd3$var$constrainMonthDay(date) {
    date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));
    date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));
}
function $735220c2d4774dd3$export$c4e2ecac49351ef2(date) {
    if (date.calendar.constrainDate) date.calendar.constrainDate(date);
    date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));
    $735220c2d4774dd3$var$constrainMonthDay(date);
}
function $735220c2d4774dd3$export$3e2544e88a25bff8(duration) {
    let inverseDuration = {};
    for(let key in duration)if (typeof duration[key] === "number") inverseDuration[key] = -duration[key];
    return inverseDuration;
}
function $735220c2d4774dd3$export$4e2d2ead65e5f7e3(date, duration) {
    return $735220c2d4774dd3$export$e16d8520af44a096(date, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$adaa4cf7ef1b65be(date, fields) {
    let mutableDate = date.copy();
    if (fields.era != null) mutableDate.era = fields.era;
    if (fields.year != null) mutableDate.year = fields.year;
    if (fields.month != null) mutableDate.month = fields.month;
    if (fields.day != null) mutableDate.day = fields.day;
    $735220c2d4774dd3$export$c4e2ecac49351ef2(mutableDate);
    return mutableDate;
}
function $735220c2d4774dd3$export$e5d5e1c1822b6e56(value, fields) {
    let mutableValue = value.copy();
    if (fields.hour != null) mutableValue.hour = fields.hour;
    if (fields.minute != null) mutableValue.minute = fields.minute;
    if (fields.second != null) mutableValue.second = fields.second;
    if (fields.millisecond != null) mutableValue.millisecond = fields.millisecond;
    $735220c2d4774dd3$export$7555de1e070510cb(mutableValue);
    return mutableValue;
}
function $735220c2d4774dd3$var$balanceTime(time) {
    time.second += Math.floor(time.millisecond / 1000);
    time.millisecond = $735220c2d4774dd3$var$nonNegativeMod(time.millisecond, 1000);
    time.minute += Math.floor(time.second / 60);
    time.second = $735220c2d4774dd3$var$nonNegativeMod(time.second, 60);
    time.hour += Math.floor(time.minute / 60);
    time.minute = $735220c2d4774dd3$var$nonNegativeMod(time.minute, 60);
    let days = Math.floor(time.hour / 24);
    time.hour = $735220c2d4774dd3$var$nonNegativeMod(time.hour, 24);
    return days;
}
function $735220c2d4774dd3$export$7555de1e070510cb(time) {
    time.millisecond = Math.max(0, Math.min(time.millisecond, 1000));
    time.second = Math.max(0, Math.min(time.second, 59));
    time.minute = Math.max(0, Math.min(time.minute, 59));
    time.hour = Math.max(0, Math.min(time.hour, 23));
}
function $735220c2d4774dd3$var$nonNegativeMod(a, b) {
    let result = a % b;
    if (result < 0) result += b;
    return result;
}
function $735220c2d4774dd3$var$addTimeFields(time, duration) {
    time.hour += duration.hours || 0;
    time.minute += duration.minutes || 0;
    time.second += duration.seconds || 0;
    time.millisecond += duration.milliseconds || 0;
    return $735220c2d4774dd3$var$balanceTime(time);
}
function $735220c2d4774dd3$export$7ed87b6bc2506470(time, duration) {
    let res = time.copy();
    $735220c2d4774dd3$var$addTimeFields(res, duration);
    return res;
}
function $735220c2d4774dd3$export$fe34d3a381cd7501(time, duration) {
    return $735220c2d4774dd3$export$7ed87b6bc2506470(time, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$d52ced6badfb9a4c(value, field, amount, options) {
    let mutable = value.copy();
    switch(field){
        case "era":
            {
                let eras = value.calendar.getEras();
                let eraIndex = eras.indexOf(value.era);
                if (eraIndex < 0) throw new Error("Invalid era: " + value.era);
                eraIndex = $735220c2d4774dd3$var$cycleValue(eraIndex, amount, 0, eras.length - 1, options === null || options === void 0 ? void 0 : options.round);
                mutable.era = eras[eraIndex];
                // Constrain the year and other fields within the era, so the era doesn't change when we balance below.
                $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
                break;
            }
        case "year":
            var _mutable_calendar_isInverseEra, _mutable_calendar;
            if ((_mutable_calendar_isInverseEra = (_mutable_calendar = mutable.calendar).isInverseEra) === null || _mutable_calendar_isInverseEra === void 0 ? void 0 : _mutable_calendar_isInverseEra.call(_mutable_calendar, mutable)) amount = -amount;
            // The year field should not cycle within the era as that can cause weird behavior affecting other fields.
            // We need to also allow values < 1 so that decrementing goes to the previous era. If we get -Infinity back
            // we know we wrapped around after reaching 9999 (the maximum), so set the year back to 1.
            mutable.year = $735220c2d4774dd3$var$cycleValue(value.year, amount, -Infinity, 9999, options === null || options === void 0 ? void 0 : options.round);
            if (mutable.year === -Infinity) mutable.year = 1;
            if (mutable.calendar.balanceYearMonth) mutable.calendar.balanceYearMonth(mutable, value);
            break;
        case "month":
            mutable.month = $735220c2d4774dd3$var$cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options === null || options === void 0 ? void 0 : options.round);
            break;
        case "day":
            mutable.day = $735220c2d4774dd3$var$cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options === null || options === void 0 ? void 0 : options.round);
            break;
        default:
            throw new Error("Unsupported field " + field);
    }
    if (value.calendar.balanceDate) value.calendar.balanceDate(mutable);
    $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
    return mutable;
}
function $735220c2d4774dd3$export$dd02b3e0007dfe28(value, field, amount, options) {
    let mutable = value.copy();
    switch(field){
        case "hour":
            {
                let hours = value.hour;
                let min = 0;
                let max = 23;
                if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
                    let isPM = hours >= 12;
                    min = isPM ? 12 : 0;
                    max = isPM ? 23 : 11;
                }
                mutable.hour = $735220c2d4774dd3$var$cycleValue(hours, amount, min, max, options === null || options === void 0 ? void 0 : options.round);
                break;
            }
        case "minute":
            mutable.minute = $735220c2d4774dd3$var$cycleValue(value.minute, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
            break;
        case "second":
            mutable.second = $735220c2d4774dd3$var$cycleValue(value.second, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
            break;
        case "millisecond":
            mutable.millisecond = $735220c2d4774dd3$var$cycleValue(value.millisecond, amount, 0, 999, options === null || options === void 0 ? void 0 : options.round);
            break;
        default:
            throw new Error("Unsupported field " + field);
    }
    return mutable;
}
function $735220c2d4774dd3$var$cycleValue(value, amount, min, max, round = false) {
    if (round) {
        value += Math.sign(amount);
        if (value < min) value = max;
        let div = Math.abs(amount);
        if (amount > 0) value = Math.ceil(value / div) * div;
        else value = Math.floor(value / div) * div;
        if (value > max) value = min;
    } else {
        value += amount;
        if (value < min) value = max - (min - value - 1);
        else if (value > max) value = min + (value - max - 1);
    }
    return value;
}
function $735220c2d4774dd3$export$96b1d28349274637(dateTime, duration) {
    let ms;
    if (duration.years != null && duration.years !== 0 || duration.months != null && duration.months !== 0 || duration.weeks != null && duration.weeks !== 0 || duration.days != null && duration.days !== 0) {
        let res = $735220c2d4774dd3$export$e16d8520af44a096(($11d87f3f76e88657$export$b21e0b124e224484)(dateTime), {
            years: duration.years,
            months: duration.months,
            weeks: duration.weeks,
            days: duration.days
        });
        // Changing the date may change the timezone offset, so we need to recompute
        // using the 'compatible' disambiguation.
        ms = ($11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone);
    } else // Otherwise, preserve the offset of the original date.
    ms = ($11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
    // Perform time manipulation in milliseconds rather than on the original time fields to account for DST.
    // For example, adding one hour during a DST transition may result in the hour field staying the same or
    // skipping an hour. This results in the offset field changing value instead of the specified field.
    ms += duration.milliseconds || 0;
    ms += (duration.seconds || 0) * 1000;
    ms += (duration.minutes || 0) * 60000;
    ms += (duration.hours || 0) * 3600000;
    let res = ($11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone);
    return ($11d87f3f76e88657$export$b4a036af3fc0b032)(res, dateTime.calendar);
}
function $735220c2d4774dd3$export$6814caac34ca03c7(dateTime, duration) {
    return $735220c2d4774dd3$export$96b1d28349274637(dateTime, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$9a297d111fc86b79(dateTime, field, amount, options) {
    // For date fields, we want the time to remain consistent and the UTC offset to potentially change to account for DST changes.
    // For time fields, we want the time to change by the amount given. This may result in the hour field staying the same, but the UTC
    // offset changing in the case of a backward DST transition, or skipping an hour in the case of a forward DST transition.
    switch(field){
        case "hour":
            {
                let min = 0;
                let max = 23;
                if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
                    let isPM = dateTime.hour >= 12;
                    min = isPM ? 12 : 0;
                    max = isPM ? 23 : 11;
                }
                // The minimum and maximum hour may be affected by daylight saving time.
                // For example, it might jump forward at midnight, and skip 1am.
                // Or it might end at midnight and repeat the 11pm hour. To handle this, we get
                // the possible absolute times for the min and max, and find the maximum range
                // that is within the current day.
                let plainDateTime = ($11d87f3f76e88657$export$b21e0b124e224484)(dateTime);
                let minDate = ($11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
                    hour: min
                }), new ($3b62074eb05584b2$export$80ee6245ec4f29ec)());
                let minAbsolute = [
                    ($11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "earlier"),
                    ($11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "later")
                ].filter((ms)=>($11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone).day === minDate.day)[0];
                let maxDate = ($11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
                    hour: max
                }), new ($3b62074eb05584b2$export$80ee6245ec4f29ec)());
                let maxAbsolute = [
                    ($11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "earlier"),
                    ($11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "later")
                ].filter((ms)=>($11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone).day === maxDate.day).pop();
                // Since hours may repeat, we need to operate on the absolute time in milliseconds.
                // This is done in hours from the Unix epoch so that cycleValue works correctly,
                // and then converted back to milliseconds.
                let ms = ($11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
                let hours = Math.floor(ms / $735220c2d4774dd3$var$ONE_HOUR);
                let remainder = ms % $735220c2d4774dd3$var$ONE_HOUR;
                ms = $735220c2d4774dd3$var$cycleValue(hours, amount, Math.floor(minAbsolute / $735220c2d4774dd3$var$ONE_HOUR), Math.floor(maxAbsolute / $735220c2d4774dd3$var$ONE_HOUR), options === null || options === void 0 ? void 0 : options.round) * $735220c2d4774dd3$var$ONE_HOUR + remainder;
                // Now compute the new timezone offset, and convert the absolute time back to local time.
                return ($11d87f3f76e88657$export$b4a036af3fc0b032)(($11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
            }
        case "minute":
        case "second":
        case "millisecond":
            // @ts-ignore
            return $735220c2d4774dd3$export$dd02b3e0007dfe28(dateTime, field, amount, options);
        case "era":
        case "year":
        case "month":
        case "day":
            {
                let res = $735220c2d4774dd3$export$d52ced6badfb9a4c(($11d87f3f76e88657$export$b21e0b124e224484)(dateTime), field, amount, options);
                let ms = ($11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone);
                return ($11d87f3f76e88657$export$b4a036af3fc0b032)(($11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
            }
        default:
            throw new Error("Unsupported field " + field);
    }
}
function $735220c2d4774dd3$export$31b5430eb18be4f8(dateTime, fields, disambiguation) {
    // Set the date/time fields, and recompute the UTC offset to account for DST changes.
    // We also need to validate by converting back to a local time in case hours are skipped during forward DST transitions.
    let plainDateTime = ($11d87f3f76e88657$export$b21e0b124e224484)(dateTime);
    let res = $735220c2d4774dd3$export$e5d5e1c1822b6e56($735220c2d4774dd3$export$adaa4cf7ef1b65be(plainDateTime, fields), fields);
    // If the resulting plain date time values are equal, return the original time.
    // We don't want to change the offset when setting the time to the same value.
    if (res.compare(plainDateTime) === 0) return dateTime;
    let ms = ($11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone, disambiguation);
    return ($11d87f3f76e88657$export$b4a036af3fc0b032)(($11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
}
function $fae977aafc393c5c$export$f59dee82248f5ad4(time) {
    return `${String(time.hour).padStart(2, "0")}:${String(time.minute).padStart(2, "0")}:${String(time.second).padStart(2, "0")}${time.millisecond ? String(time.millisecond / 1000).slice(1) : ""}`;
}
function $fae977aafc393c5c$export$60dfd74aa96791bd(date) {
    let gregorianDate = ($11d87f3f76e88657$export$b4a036af3fc0b032)(date, new ($3b62074eb05584b2$export$80ee6245ec4f29ec)());
    return `${String(gregorianDate.year).padStart(4, "0")}-${String(gregorianDate.month).padStart(2, "0")}-${String(gregorianDate.day).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$4223de14708adc63(date) {
    // @ts-ignore
    return `${$fae977aafc393c5c$export$60dfd74aa96791bd(date)}T${$fae977aafc393c5c$export$f59dee82248f5ad4(date)}`;
}
function $fae977aafc393c5c$var$offsetToString(offset) {
    let sign = Math.sign(offset) < 0 ? "-" : "+";
    offset = Math.abs(offset);
    let offsetHours = Math.floor(offset / 3600000);
    let offsetMinutes = offset % 3600000 / 60000;
    return `${sign}${String(offsetHours).padStart(2, "0")}:${String(offsetMinutes).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$bf79f1ebf4b18792(date) {
    return `${$fae977aafc393c5c$export$4223de14708adc63(date)}${$fae977aafc393c5c$var$offsetToString(date.offset)}[${date.timeZone}]`;
}




function $35ea8db9cb2ccb90$var$shiftArgs(args) {
    let calendar = typeof args[0] === "object" ? args.shift() : new ($3b62074eb05584b2$export$80ee6245ec4f29ec)();
    let era;
    if (typeof args[0] === "string") era = args.shift();
    else {
        let eras = calendar.getEras();
        era = eras[eras.length - 1];
    }
    let year = args.shift();
    let month = args.shift();
    let day = args.shift();
    return [
        calendar,
        era,
        year,
        month,
        day
    ];
}
var // This prevents TypeScript from allowing other types with the same fields to match.
// i.e. a ZonedDateTime should not be be passable to a parameter that expects CalendarDate.
// If that behavior is desired, use the AnyCalendarDate interface instead.
// @ts-ignore
$35ea8db9cb2ccb90$var$_type = /*#__PURE__*/ new WeakMap();
class $35ea8db9cb2ccb90$export$99faa760c7908e4f {
    /** Returns a copy of this date. */ copy() {
        if (this.era) return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.era, this.year, this.month, this.day);
        else return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.year, this.month, this.day);
    }
    /** Returns a new `CalendarDate` with the given duration added to it. */ add(duration) {
        return ($735220c2d4774dd3$export$e16d8520af44a096)(this, duration);
    }
    /** Returns a new `CalendarDate` with the given duration subtracted from it. */ subtract(duration) {
        return ($735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);
    }
    /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {
        return ($735220c2d4774dd3$export$adaa4cf7ef1b65be)(this, fields);
    }
    /**
   * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
   * When the resulting value reaches the limits of the field, it wraps around.
   */ cycle(field, amount, options) {
        return ($735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);
    }
    /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */ toDate(timeZone) {
        return ($11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone);
    }
    /** Converts the date to an ISO 8601 formatted string. */ toString() {
        return ($fae977aafc393c5c$export$60dfd74aa96791bd)(this);
    }
    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {
        return ($14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b);
    }
    constructor(...args){
        (_class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type, {
            writable: true,
            value: void 0
        });
        let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
        this.calendar = calendar;
        this.era = era;
        this.year = year;
        this.month = month;
        this.day = day;
        ($735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
    }
}
var // This prevents TypeScript from allowing other types with the same fields to match.
// @ts-ignore
$35ea8db9cb2ccb90$var$_type1 = /*#__PURE__*/ new WeakMap();
class $35ea8db9cb2ccb90$export$680ea196effce5f {
    /** Returns a copy of this time. */ copy() {
        return new $35ea8db9cb2ccb90$export$680ea196effce5f(this.hour, this.minute, this.second, this.millisecond);
    }
    /** Returns a new `Time` with the given duration added to it. */ add(duration) {
        return ($735220c2d4774dd3$export$7ed87b6bc2506470)(this, duration);
    }
    /** Returns a new `Time` with the given duration subtracted from it. */ subtract(duration) {
        return ($735220c2d4774dd3$export$fe34d3a381cd7501)(this, duration);
    }
    /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {
        return ($735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields);
    }
    /**
   * Returns a new `Time` with the given field adjusted by a specified amount.
   * When the resulting value reaches the limits of the field, it wraps around.
   */ cycle(field, amount, options) {
        return ($735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);
    }
    /** Converts the time to an ISO 8601 formatted string. */ toString() {
        return ($fae977aafc393c5c$export$f59dee82248f5ad4)(this);
    }
    /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */ compare(b) {
        return ($14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, b);
    }
    constructor(hour = 0, minute = 0, second = 0, millisecond = 0){
        (_class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type1, {
            writable: true,
            value: void 0
        });
        this.hour = hour;
        this.minute = minute;
        this.second = second;
        this.millisecond = millisecond;
        ($735220c2d4774dd3$export$7555de1e070510cb)(this);
    }
}
var // This prevents TypeScript from allowing other types with the same fields to match.
// @ts-ignore
$35ea8db9cb2ccb90$var$_type2 = /*#__PURE__*/ new WeakMap();
class $35ea8db9cb2ccb90$export$ca871e8dbb80966f {
    /** Returns a copy of this date. */ copy() {
        if (this.era) return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
        else return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
    }
    /** Returns a new `CalendarDateTime` with the given duration added to it. */ add(duration) {
        return ($735220c2d4774dd3$export$e16d8520af44a096)(this, duration);
    }
    /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */ subtract(duration) {
        return ($735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);
    }
    /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {
        return ($735220c2d4774dd3$export$adaa4cf7ef1b65be)(($735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields), fields);
    }
    /**
   * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
   * When the resulting value reaches the limits of the field, it wraps around.
   */ cycle(field, amount, options) {
        switch(field){
            case "era":
            case "year":
            case "month":
            case "day":
                return ($735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);
            default:
                return ($735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);
        }
    }
    /** Converts the date to a native JavaScript Date object in the given time zone. */ toDate(timeZone, disambiguation) {
        return ($11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone, disambiguation);
    }
    /** Converts the date to an ISO 8601 formatted string. */ toString() {
        return ($fae977aafc393c5c$export$4223de14708adc63)(this);
    }
    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {
        let res = ($14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b);
        if (res === 0) return ($14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, ($11d87f3f76e88657$export$b21e0b124e224484)(b));
        return res;
    }
    constructor(...args){
        (_class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type2, {
            writable: true,
            value: void 0
        });
        let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
        this.calendar = calendar;
        this.era = era;
        this.year = year;
        this.month = month;
        this.day = day;
        this.hour = args.shift() || 0;
        this.minute = args.shift() || 0;
        this.second = args.shift() || 0;
        this.millisecond = args.shift() || 0;
        ($735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
    }
}
var // This prevents TypeScript from allowing other types with the same fields to match.
// @ts-ignore
$35ea8db9cb2ccb90$var$_type3 = /*#__PURE__*/ new WeakMap();
class $35ea8db9cb2ccb90$export$d3b7288e7994edea {
    /** Returns a copy of this date. */ copy() {
        if (this.era) return new $35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
        else return new $35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
    }
    /** Returns a new `ZonedDateTime` with the given duration added to it. */ add(duration) {
        return ($735220c2d4774dd3$export$96b1d28349274637)(this, duration);
    }
    /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */ subtract(duration) {
        return ($735220c2d4774dd3$export$6814caac34ca03c7)(this, duration);
    }
    /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields, disambiguation) {
        return ($735220c2d4774dd3$export$31b5430eb18be4f8)(this, fields, disambiguation);
    }
    /**
   * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
   * When the resulting value reaches the limits of the field, it wraps around.
   */ cycle(field, amount, options) {
        return ($735220c2d4774dd3$export$9a297d111fc86b79)(this, field, amount, options);
    }
    /** Converts the date to a native JavaScript Date object. */ toDate() {
        return ($11d87f3f76e88657$export$83aac07b4c37b25)(this);
    }
    /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */ toString() {
        return ($fae977aafc393c5c$export$bf79f1ebf4b18792)(this);
    }
    /** Converts the date to an ISO 8601 formatted string in UTC. */ toAbsoluteString() {
        return this.toDate().toISOString();
    }
    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {
        // TODO: Is this a bad idea??
        return this.toDate().getTime() - ($11d87f3f76e88657$export$84c95a83c799e074)(b, this.timeZone).toDate().getTime();
    }
    constructor(...args){
        (_class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type3, {
            writable: true,
            value: void 0
        });
        let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
        let timeZone = args.shift();
        let offset = args.shift();
        this.calendar = calendar;
        this.era = era;
        this.year = year;
        this.month = month;
        this.day = day;
        this.timeZone = timeZone;
        this.offset = offset;
        this.hour = args.shift() || 0;
        this.minute = args.shift() || 0;
        this.second = args.shift() || 0;
        this.millisecond = args.shift() || 0;
        ($735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
    }
}





/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ let $fb18d541ea1ad717$var$formatterCache = new Map();
class $fb18d541ea1ad717$export$ad991b66133851cf {
    /** Formats a date as a string according to the locale and format options passed to the constructor. */ format(value) {
        return this.formatter.format(value);
    }
    /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */ formatToParts(value) {
        return this.formatter.formatToParts(value);
    }
    /** Formats a date range as a string. */ formatRange(start, end) {
        // @ts-ignore
        if (typeof this.formatter.formatRange === "function") // @ts-ignore
        return this.formatter.formatRange(start, end);
        if (end < start) throw new RangeError("End date must be >= start date");
        // Very basic fallback for old browsers.
        return `${this.formatter.format(start)} \u{2013} ${this.formatter.format(end)}`;
    }
    /** Formats a date range as an array of parts. */ formatRangeToParts(start, end) {
        // @ts-ignore
        if (typeof this.formatter.formatRangeToParts === "function") // @ts-ignore
        return this.formatter.formatRangeToParts(start, end);
        if (end < start) throw new RangeError("End date must be >= start date");
        let startParts = this.formatter.formatToParts(start);
        let endParts = this.formatter.formatToParts(end);
        return [
            ...startParts.map((p)=>({
                    ...p,
                    source: "startRange"
                })),
            {
                type: "literal",
                value: " \u2013 ",
                source: "shared"
            },
            ...endParts.map((p)=>({
                    ...p,
                    source: "endRange"
                }))
        ];
    }
    /** Returns the resolved formatting options based on the values passed to the constructor. */ resolvedOptions() {
        let resolvedOptions = this.formatter.resolvedOptions();
        if ($fb18d541ea1ad717$var$hasBuggyResolvedHourCycle()) {
            if (!this.resolvedHourCycle) this.resolvedHourCycle = $fb18d541ea1ad717$var$getResolvedHourCycle(resolvedOptions.locale, this.options);
            resolvedOptions.hourCycle = this.resolvedHourCycle;
            resolvedOptions.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12";
        }
        // Safari uses a different name for the Ethiopic (Amete Alem) calendar.
        // https://bugs.webkit.org/show_bug.cgi?id=241564
        if (resolvedOptions.calendar === "ethiopic-amete-alem") resolvedOptions.calendar = "ethioaa";
        return resolvedOptions;
    }
    constructor(locale, options = {}){
        this.formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options);
        this.options = options;
    }
}
// There are multiple bugs involving the hour12 and hourCycle options in various browser engines.
//   - Chrome [1] (and the ECMA 402 spec [2]) resolve hour12: false in English and other locales to h24 (24:00 - 23:59)
//     rather than h23 (00:00 - 23:59). Same can happen with hour12: true in French, which Chrome resolves to h11 (00:00 - 11:59)
//     rather than h12 (12:00 - 11:59).
//   - WebKit returns an incorrect hourCycle resolved option in the French locale due to incorrect parsing of 'h' literal
//     in the resolved pattern. It also formats incorrectly when specifying the hourCycle option for the same reason. [3]
// [1] https://bugs.chromium.org/p/chromium/issues/detail?id=1045791
// [2] https://github.com/tc39/ecma402/issues/402
// [3] https://bugs.webkit.org/show_bug.cgi?id=229313
// https://github.com/unicode-org/cldr/blob/018b55eff7ceb389c7e3fc44e2f657eae3b10b38/common/supplemental/supplementalData.xml#L4774-L4802
const $fb18d541ea1ad717$var$hour12Preferences = {
    true: {
        // Only Japanese uses the h11 style for 12 hour time. All others use h12.
        ja: "h11"
    },
    false: {
    }
};
function $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options = {}) {
    // Work around buggy hour12 behavior in Chrome / ECMA 402 spec by using hourCycle instead.
    // Only apply the workaround if the issue is detected, because the hourCycle option is buggy in Safari.
    if (typeof options.hour12 === "boolean" && $fb18d541ea1ad717$var$hasBuggyHour12Behavior()) {
        options = {
            ...options
        };
        let pref = $fb18d541ea1ad717$var$hour12Preferences[String(options.hour12)][locale.split("-")[0]];
        let defaultHourCycle = options.hour12 ? "h12" : "h23";
        options.hourCycle = pref !== null && pref !== void 0 ? pref : defaultHourCycle;
        delete options.hour12;
    }
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : "");
    if ($fb18d541ea1ad717$var$formatterCache.has(cacheKey)) return $fb18d541ea1ad717$var$formatterCache.get(cacheKey);
    let numberFormatter = new Intl.DateTimeFormat(locale, options);
    $fb18d541ea1ad717$var$formatterCache.set(cacheKey, numberFormatter);
    return numberFormatter;
}
let $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = null;
function $fb18d541ea1ad717$var$hasBuggyHour12Behavior() {
    if ($fb18d541ea1ad717$var$_hasBuggyHour12Behavior == null) $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = new Intl.DateTimeFormat("en-US", {
        hour: "numeric",
        hour12: false
    }).format(new Date(2020, 2, 3, 0)) === "24";
    return $fb18d541ea1ad717$var$_hasBuggyHour12Behavior;
}
let $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = null;
function $fb18d541ea1ad717$var$hasBuggyResolvedHourCycle() {
    if ($fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle == null) $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = new Intl.DateTimeFormat("fr", {
        hour: "numeric",
        hour12: false
    }).resolvedOptions().hourCycle === "h12";
    return $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle;
}
function $fb18d541ea1ad717$var$getResolvedHourCycle(locale, options) {
    if (!options.timeStyle && !options.hour) return undefined;
    // Work around buggy results in resolved hourCycle and hour12 options in WebKit.
    // Format the minimum possible hour and maximum possible hour in a day and parse the results.
    locale = locale.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, "");
    locale += (locale.includes("-u-") ? "" : "-u") + "-nu-latn";
    let formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, {
        ...options,
        timeZone: undefined // use local timezone
    });
    let min = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 0)).find((p)=>p.type === "hour").value, 10);
    let max = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 23)).find((p)=>p.type === "hour").value, 10);
    if (min === 0 && max === 23) return "h23";
    if (min === 24 && max === 23) return "h24";
    if (min === 0 && max === 11) return "h11";
    if (min === 12 && max === 11) return "h12";
    throw new Error("Unexpected hour cycle result");
}

// These are the standard Date Formats being followed globally
const SUPPORTED_DATE_FORMATS = [
    // Date formats
    {
        regex: /^(\d{4})\/(0[1-9]|1[0-2])\/(\d{2})$/,
        yearIndex: 1,
        monthIndex: 2,
        dayIndex: 3,
        format: 'YYYY/MM/DD',
    },
    {
        regex: /^(\d{2})\/(0[1-9]|1[0-2])\/(\d{4})$/,
        yearIndex: 3,
        monthIndex: 2,
        dayIndex: 1,
        format: 'DD/MM/YYYY',
    },
    {
        regex: /^(\d{4})\.(0[1-9]|1[0-2])\.(\d{2})$/,
        yearIndex: 1,
        monthIndex: 2,
        dayIndex: 3,
        format: 'YYYY.MM.DD',
    },
    {
        regex: /^(\d{2})-(0[1-9]|1[0-2])-(\d{4})$/,
        yearIndex: 3,
        monthIndex: 2,
        dayIndex: 1,
        format: 'DD-MM-YYYY',
    },
    {
        regex: /^(0[1-9]|1[0-2])\/(\d{2})\/(\d{4})$/,
        yearIndex: 3,
        monthIndex: 1,
        dayIndex: 2,
        format: 'MM/DD/YYYY',
    },
    {
        regex: /^(\d{4})-(0[1-9]|1[0-2])-(\d{2})$/,
        yearIndex: 1,
        monthIndex: 2,
        dayIndex: 3,
        format: 'YYYY-MM-DD',
    },
    {
        regex: /^(\d{4})\.\s*(0[1-9]|1[0-2])\.\s*(\d{2})\.\s*$/,
        yearIndex: 1,
        monthIndex: 2,
        dayIndex: 3,
        format: 'YYYY. MM. DD.',
    },
    {
        regex: /^(\d{2})\.(0[1-9]|1[0-2])\.(\d{4})$/,
        yearIndex: 3,
        monthIndex: 2,
        dayIndex: 1,
        format: 'DD.MM.YYYY',
    },
    {
        regex: /^(0[1-9]|1[0-2])\.(\d{2})\.(\d{4})$/,
        yearIndex: 3,
        monthIndex: 1,
        dayIndex: 2,
        format: 'MM.DD.YYYY',
    },
    // Timestamp formats
    {
        regex: /^(\d{4})\/(0[1-9]|1[0-2])\/(\d{2}) (\d{2}):(\d{2}):(\d{2})$/,
        yearIndex: 1,
        monthIndex: 2,
        dayIndex: 3,
        hourIndex: 4,
        minuteIndex: 5,
        secondIndex: 6,
        format: 'YYYY/MM/DD HH:MM:SS',
    },
    {
        regex: /^(\d{2})\/(0[1-9]|1[0-2])\/(\d{4}) (\d{2}):(\d{2}):(\d{2})$/,
        yearIndex: 3,
        monthIndex: 2,
        dayIndex: 1,
        hourIndex: 4,
        minuteIndex: 5,
        secondIndex: 6,
        format: 'DD/MM/YYYY HH:MM:SS',
    },
    {
        regex: /^(\d{4})-(0[1-9]|1[0-2])-(\d{2}) (\d{2}):(\d{2}):(\d{2})$/,
        yearIndex: 1,
        monthIndex: 2,
        dayIndex: 3,
        hourIndex: 4,
        minuteIndex: 5,
        secondIndex: 6,
        format: 'YYYY-MM-DD HH:MM:SS',
    },
    {
        regex: /^(\d{2})-(0[1-9]|1[0-2])-(\d{4}) (\d{2}):(\d{2}):(\d{2})$/,
        yearIndex: 3,
        monthIndex: 2,
        dayIndex: 1,
        hourIndex: 4,
        minuteIndex: 5,
        secondIndex: 6,
        format: 'DD-MM-YYYY HH:MM:SS',
    },
    {
        regex: /^(\d{4})\.(0[1-9]|1[0-2])\.(\d{2}) (\d{2}):(\d{2}):(\d{2})$/,
        yearIndex: 1,
        monthIndex: 2,
        dayIndex: 3,
        hourIndex: 4,
        minuteIndex: 5,
        secondIndex: 6,
        format: 'YYYY.MM.DD HH:MM:SS',
    },
    {
        regex: /^(\d{2})\.(0[1-9]|1[0-2])\.(\d{4}) (\d{2}):(\d{2}):(\d{2})$/,
        yearIndex: 3,
        monthIndex: 2,
        dayIndex: 1,
        hourIndex: 4,
        minuteIndex: 5,
        secondIndex: 6,
        format: 'DD.MM.YYYY HH:MM:SS',
    },
    // ISO 8601 Timestamp format
    {
        regex: /^(\d{4})-(0[1-9]|1[0-2])-(\d{2})T(\d{2}):(\d{2}):(\d{2})$/,
        yearIndex: 1,
        monthIndex: 2,
        dayIndex: 3,
        hourIndex: 4,
        minuteIndex: 5,
        secondIndex: 6,
        format: 'YYYY-MM-DDTHH:MM:SS',
    },
];

/**
 * Converts a string representation of a date into a Date object.
 * The function supports various date and timestamp formats,
 * including both American and European styles, with or without time components.
 * If the provided string doesn't match any of the supported formats,
 * the function throws an error.
 *
 * @param {string} dateString - The date string to be converted to a Date object.
 * @returns {Date} A Date object representing the date and time specified in the dateString.
 * @throws {Error} If the date format is not recognized.
 */
const stringToDate = (dateString) => {
    // Iterate through each supported date format.
    for (const format of SUPPORTED_DATE_FORMATS) {
        const match = dateString.match(format.regex);
        if (match) {
            // Extract year, month, and day from the matched groups.
            const year = match[format.yearIndex];
            const month = match[format.monthIndex];
            const day = match[format.dayIndex];
            // Extract time components if available, defaulting to '00' if not present.
            const hour = format.hourIndex ? match[format.hourIndex] : '00';
            const minute = format.minuteIndex ? match[format.minuteIndex] : '00';
            const second = format.secondIndex ? match[format.secondIndex] : '00';
            // Construct and return the Date object.
            try {
                const dateObj = new Date(`${year}-${month}-${day}T${hour}:${minute}:${second}`);
                if (dateObj.getTime())
                    return dateObj;
                else
                    throw new Error(`Invalid Date! The constructed date from the provided string "${dateString}" is invalid. Please ensure the date string is correct.`);
            }
            catch (err) {
                if (err instanceof Error) {
                    throw new Error(`An error occurred while constructing the date: ${err.message}. Please ensure the date string "${dateString}" is in a supported format.`);
                }
                else {
                    throw new Error(`An unknown error occurred. Error details: ${err}`);
                }
            }
        }
    }
    // If no format matches, throw an error.
    throw new Error(`Date format not recognized. The provided date string "${dateString}" does not match any supported formats. Please use a recognized date format.`);
};
const convertToStandardDate = (date) => {
    const standardDate = typeof date === 'string' ? new Date(stringToDate(date)) : new Date(date);
    return standardDate;
};

/**
 * Formats date and time based on the locale.
 * @param {DateInput} date - Date object or date string.
 * @param options - Config object.
 * @returns {string} Formatted date and time string.
 */
const formatDateTime = (date, options = {}) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    const extractedLocale = getLocale(options);
    const standardDate = convertToStandardDate(date);
    let finalIntlOptions = {};
    switch (options.dateTimeMode) {
        case 'dateOnly':
            finalIntlOptions = {
                year: ((_a = options.intlOptions) === null || _a === void 0 ? void 0 : _a.year) || 'numeric',
                month: ((_b = options.intlOptions) === null || _b === void 0 ? void 0 : _b.month) || 'numeric',
                day: ((_c = options.intlOptions) === null || _c === void 0 ? void 0 : _c.day) || 'numeric',
            };
            break;
        case 'timeOnly':
            finalIntlOptions = {
                hour: ((_d = options.intlOptions) === null || _d === void 0 ? void 0 : _d.hour) || 'numeric',
                minute: ((_e = options.intlOptions) === null || _e === void 0 ? void 0 : _e.minute) || 'numeric',
                second: ((_f = options.intlOptions) === null || _f === void 0 ? void 0 : _f.second) || 'numeric',
            };
            if (((_g = options.intlOptions) === null || _g === void 0 ? void 0 : _g.hour12) !== undefined)
                finalIntlOptions.hour12 = (_h = options.intlOptions) === null || _h === void 0 ? void 0 : _h.hour12;
            break;
        case 'dateTime':
            finalIntlOptions = {
                year: ((_j = options.intlOptions) === null || _j === void 0 ? void 0 : _j.year) || 'numeric',
                month: ((_k = options.intlOptions) === null || _k === void 0 ? void 0 : _k.month) || 'numeric',
                day: ((_l = options.intlOptions) === null || _l === void 0 ? void 0 : _l.day) || 'numeric',
                hour: ((_m = options.intlOptions) === null || _m === void 0 ? void 0 : _m.hour) || 'numeric',
                minute: ((_o = options.intlOptions) === null || _o === void 0 ? void 0 : _o.minute) || 'numeric',
                second: ((_p = options.intlOptions) === null || _p === void 0 ? void 0 : _p.second) || 'numeric',
            };
            if (((_q = options.intlOptions) === null || _q === void 0 ? void 0 : _q.hour12) !== undefined)
                finalIntlOptions.hour12 = (_r = options.intlOptions) === null || _r === void 0 ? void 0 : _r.hour12;
            break;
        default:
            finalIntlOptions = Object.assign({}, options.intlOptions);
    }
    let formatter;
    try {
        formatter = new $fb18d541ea1ad717$export$ad991b66133851cf(extractedLocale, finalIntlOptions);
    }
    catch (err) {
        if (err instanceof Error) {
            throw new Error(`An error occurred while creating the DateFormatter instance: ${err.message}. Please ensure the provided options are valid and try again.`);
        }
        else {
            throw new Error(`An unknown error occurred. Error details: ${err}`);
        }
    }
    return formatter.format(new Date(standardDate));
};
var formatDateTime$1 = withErrorBoundary(formatDateTime);

/**
 * Provides a relative time string (e.g., '3 hours ago', 'in 2 days').
 * This function calculates the difference between the given date and the base date,
 * then formats it in a locale-sensitive manner. It allows customization of the output
 * through Intl.RelativeTimeFormat options.
 *
 * @param date - The date to compare.
 * @param options - Config object.
 * @returns The relative time as a string.
 */
const getRelativeTime = (date, options = {}) => {
    const standardDate = convertToStandardDate(date);
    const standardBaseDate = convertToStandardDate(options.baseDate || new Date());
    const locale = getLocale(options);
    const diffInSeconds = (standardDate.getTime() - standardBaseDate.getTime()) / 1000;
    // Define time units in seconds
    const minute = 60;
    const hour = minute * 60;
    const day = hour * 24;
    const week = day * 7;
    const month = day * 30;
    const year = day * 365;
    let value;
    let unit;
    if (Math.abs(diffInSeconds) < minute) {
        value = diffInSeconds;
        unit = 'second';
    }
    else if (Math.abs(diffInSeconds) < hour) {
        value = diffInSeconds / minute;
        unit = 'minute';
    }
    else if (Math.abs(diffInSeconds) < day) {
        value = diffInSeconds / hour;
        unit = 'hour';
    }
    else if (Math.abs(diffInSeconds) < week) {
        value = diffInSeconds / day;
        unit = 'day';
    }
    else if (Math.abs(diffInSeconds) < month) {
        value = diffInSeconds / week;
        unit = 'week';
    }
    else if (Math.abs(diffInSeconds) < year) {
        value = diffInSeconds / month;
        unit = 'month';
    }
    else {
        value = diffInSeconds / year;
        unit = 'year';
    }
    let relativeTime;
    try {
        const rtf = new Intl.RelativeTimeFormat(locale, options.intlOptions);
        relativeTime = rtf.format(Math.round(value), unit);
    }
    catch (err) {
        if (err instanceof Error) {
            throw new Error(`An error occurred while creating the RelativeTimeFormat instance: ${err.message}. Please ensure the provided options are valid and try again.`);
        }
        else {
            throw new Error(`An unknown error occurred. Error details: ${err}`);
        }
    }
    return relativeTime;
};
var getRelativeTime$1 = withErrorBoundary(getRelativeTime);

/**
 * Returns an array of weekdays according to the specified locale.
 *
 * @param options Config object
 * @returns An array of weekday names.
 */
const getWeekdays = (options) => {
    try {
        const locale = getLocale(options);
        const formatter = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
            weekday: options.weekday || 'long',
        });
        /** The date January 1, 1970, is a well-known reference point in computing known as the Unix epoch.
         * It's the date at which time is measured for Unix systems, making it a consistent and reliable choice for date calculations.
         * The choice of the date January 4, 1970, as the starting point is significant.
         * January 4, 1970, was a Sunday.
         * Since weeks typically start on Sunday or Monday in most locales, starting from a known Sunday allows the function to cycle through a complete week, capturing all weekdays in the order they appear for the given locale.
         * */
        return Array.from({ length: 7 }, (_, i) => formatter.format(new Date(1970, 0, 4 + i)));
    }
    catch (err) {
        if (err instanceof Error) {
            throw new Error(`An error occurred while creating the DateFormatter instance or formatting the weekdays: ${err.message}. Please ensure the provided options are valid and try again.`);
        }
        else {
            throw new Error(`An unknown error occurred. Error details: ${err}`);
        }
    }
};
var getWeekdays$1 = withErrorBoundary(getWeekdays);

const ALLOWED_FORMAT_PARTS_KEYS = [
    'day',
    'dayPeriod',
    'era',
    'fractionalSecond',
    'hour',
    'minute',
    'month',
    'relatedYear',
    'second',
    'timeZone',
    'weekday',
    'year',
    'yearName',
];

/**
 * Parses a date input and returns a detailed object containing various date components
 * and their formatted representations.
 *
 * @param {DateInput} date - The date input, can be a string or a Date object.
 * @param options - Config object.
 * @returns {ParsedDateTime} An object containing the parsed date and its components.
 */
const parseDateTime = (date, options = {}) => {
    // Parse the input date, converting strings to Date objects if necessary
    const standardDate = convertToStandardDate(date);
    const locale = getLocale(options);
    try {
        // Create an DateFormatter instance for formatting
        const dateTimeFormat = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options.intlOptions);
        const formattedParts = dateTimeFormat.formatToParts(standardDate);
        const formattedObj = {};
        // Iterate over each part of the formatted date
        formattedParts.forEach((part) => {
            // If the part is allowed, add it to the formatted object
            // @ts-expect-error only allowed keys are added to the formattedObj. For eg, key 'literal', 'unknown' is skipped
            if (ALLOWED_FORMAT_PARTS_KEYS.includes(part.type)) {
                // @ts-expect-error only allowed keys are added to the formattedObj. For eg, key 'literal', 'unknown' is skipped
                formattedObj[part.type] = (formattedObj[part.type] || '') + part.value;
            }
        });
        // Return the detailed parsed date object
        return Object.assign(Object.assign({}, formattedObj), { rawParts: formattedParts, formattedDate: formattedParts.map((p) => p.value).join(''), date: standardDate });
    }
    catch (err) {
        // Handle any errors that occur during parsing
        if (err instanceof Error) {
            throw new Error(`An error occurred while parsing the date: ${err.message}. Please ensure the provided date and options are valid and try again.`);
        }
        else {
            throw new Error(`An unknown error occurred. Error details: ${err}`);
        }
    }
};
var parseDateTime$1 = withErrorBoundary(parseDateTime);

const FLAG_4X3_BASE_PATH = 'https://unpkg.com/@razorpay/i18nify-js/lib/assets/flags';
const FLAG_BASE_PATH = 'https://flagcdn.com';
const I18NIFY_DATA_SOURCE = 'https://raw.githubusercontent.com/razorpay/i18nify/master/i18nify-data';
const I18NIFY_DATA_SUPPORTED_COUNTRIES = ['IN', 'MY', 'SG', 'US'];

const LIST_OF_ALL_COUNTRIES = [
    'AD',
    'AE',
    'AF',
    'AG',
    'AI',
    'AL',
    'AM',
    'AO',
    'AQ',
    'AR',
    'AS',
    'AT',
    'AU',
    'AW',
    'AX',
    'AZ',
    'BA',
    'BB',
    'BD',
    'BE',
    'BF',
    'BG',
    'BH',
    'BI',
    'BJ',
    'BL',
    'BM',
    'BN',
    'BO',
    'BQ-BO',
    'BQ-SA',
    'BQ-SE',
    'BQ',
    'BR',
    'BS',
    'BT',
    'BV',
    'BW',
    'BY',
    'BZ',
    'CA',
    'CC',
    'CD',
    'CF',
    'CG',
    'CH',
    'CI',
    'CK',
    'CL',
    'CM',
    'CN',
    'CO',
    'CR',
    'CU',
    'CV',
    'CW',
    'CX',
    'CY',
    'CZ',
    'DE',
    'DJ',
    'DK',
    'DM',
    'DO',
    'DZ',
    'EC',
    'EE',
    'EG',
    'EH',
    'ER',
    'ES',
    'ET',
    'FI',
    'FJ',
    'FK',
    'FM',
    'FO',
    'FR',
    'GA',
    'GB-ENG',
    'GB-NIR',
    'GB-SCT',
    'GB-UKM',
    'GB-WLS',
    'GB',
    'GD',
    'GE',
    'GF',
    'GG',
    'GH',
    'GI',
    'GL',
    'GM',
    'GN',
    'GP',
    'GQ',
    'GR',
    'GS',
    'GT',
    'GU',
    'GW',
    'GY',
    'HK',
    'HM',
    'HN',
    'HR',
    'HT',
    'HU',
    'ID',
    'IE',
    'IL',
    'IM',
    'IN',
    'IO',
    'IQ',
    'IR',
    'IS',
    'IT',
    'JE',
    'JM',
    'JO',
    'JP',
    'KE',
    'KG',
    'KH',
    'KI',
    'KM',
    'KN',
    'KP',
    'KR',
    'KW',
    'KY',
    'KZ',
    'LA',
    'LB',
    'LC',
    'LI',
    'LK',
    'LR',
    'LS',
    'LT',
    'LU',
    'LV',
    'LY',
    'MA',
    'MC',
    'MD',
    'ME',
    'MF',
    'MG',
    'MH',
    'MK',
    'ML',
    'MM',
    'MN',
    'MO',
    'MP',
    'MQ',
    'MR',
    'MS',
    'MT',
    'MU',
    'MV',
    'MW',
    'MX',
    'MY',
    'MZ',
    'NA',
    'NC',
    'NE',
    'NF',
    'NG',
    'NI',
    'NL',
    'NO',
    'NP',
    'NR',
    'NU',
    'NZ',
    'OM',
    'PA',
    'PE',
    'PF',
    'PG',
    'PH',
    'PK',
    'PL',
    'PM',
    'PN',
    'PR',
    'PS',
    'PT',
    'PW',
    'PY',
    'QA',
    'RE',
    'RO',
    'RS',
    'RU',
    'RW',
    'SA',
    'SB',
    'SC',
    'SD',
    'SE',
    'SG',
    'SH',
    'SI',
    'SJ',
    'SK',
    'SL',
    'SM',
    'SN',
    'SO',
    'SR',
    'SS',
    'ST',
    'SV',
    'SX',
    'SY',
    'SZ',
    'TC',
    'TD',
    'TF',
    'TG',
    'TH',
    'TJ',
    'TK',
    'TL',
    'TM',
    'TN',
    'TO',
    'TR',
    'TT',
    'TV',
    'TW',
    'TZ',
    'UA',
    'UG',
    'UM',
    'US',
    'UY',
    'UZ',
    'VA',
    'VC',
    'VE',
    'VG',
    'VI',
    'VN',
    'VU',
    'WF',
    'WS',
    'YE',
    'YT-UNF',
    'YT',
    'ZA',
    'ZM',
    'ZW',
];

function isCountryValid(_countryCode) {
    const countryCode = _countryCode.toUpperCase();
    // @ts-expect-error countryCode here can be a random string
    return LIST_OF_ALL_COUNTRIES.includes(countryCode);
}

/**
 * Retrieves the URL for the flag of a given country.
 *
 * This function checks if the provided country code is valid by verifying it against
 * a predefined list of country codes. If the country code is valid, it constructs and
 * returns a URL pointing to the flag image for that country. If the country code is not
 * found in the list, it throws an error indicating that the country code is invalid.
 *
 * @param countryCode - The country code for which to retrieve the flag URL. Must be a valid code from the list of all countries.
 * @returns The URL of the flag image for the given country code.
 * @throws {Error} If the country code is not in the list of valid country codes.
 */
const getFlagOfCountry = (_countryCode) => {
    if (!isCountryValid(_countryCode)) {
        throw new Error(`The provided country code is invalid. The received value was: ${_countryCode}. Please ensure you pass a valid country code. Check valid country codes here: https://github.com/razorpay/i18nify/blob/master/i18nify-data/country/metadata/data.json`);
    }
    const countryCode = _countryCode.toLowerCase();
    return {
        original: `${FLAG_BASE_PATH}/${countryCode}.svg`,
        '4X3': `${FLAG_4X3_BASE_PATH}/${countryCode}.svg`,
    };
};
var getFlagOfCountry$1 = withErrorBoundary(getFlagOfCountry);

/**
 * Retrieves a mapping of country codes to their corresponding flag image URLs.
 *
 * This function iterates over a predefined list of country codes, constructs a URL
 * for each country's flag image based on the country code, and then returns an object
 * where each key is a country code and its value is the URL to that country's flag image.
 *
 * @returns An object mapping each country code from the list to its flag image URL.
 */
const getFlagsForAllCountries = () => {
    // Initialize an empty object to hold the country code to flag URL mapping
    const flagsForAllCountriesMap = {};
    // Loop through each country code in the list
    LIST_OF_ALL_COUNTRIES.map((countryCode) => {
        const lowerCasedCountryCode = countryCode.toLowerCase();
        // Construct the flag image URL and assign it to the corresponding country code in the map
        flagsForAllCountriesMap[countryCode] = {
            original: `${FLAG_BASE_PATH}/${lowerCasedCountryCode}.svg`,
            '4X3': `${FLAG_4X3_BASE_PATH}/${lowerCasedCountryCode}.svg`,
        };
    });
    // Return the populated map of country codes to flag image URLs
    return flagsForAllCountriesMap;
};
var getFlagsForAllCountries$1 = withErrorBoundary(getFlagsForAllCountries);

/**
 * Retrieves the meta data for all countries
 *
 * This function makes a network request to central i18nify-data source and
 * returns a promise for list of all countries with their meta data
 *
 * @returns {Promise} Promise object for all countries
 */
const getAllCountries = () => {
    return fetch(`${I18NIFY_DATA_SOURCE}/country/metadata/data.json`)
        .then((res) => res.json())
        .then((res) => res.metadata_information)
        .catch((err) => {
        throw new Error(`An error occurred while fetching country metadata. The error details are: ${err.message}.`);
    });
};
var getAllCountries$1 = withErrorBoundary(getAllCountries);

/**
 * Retrieves the list of states for a country
 *
 * This function makes a network request to central i18nify-data source and
 * returns a promise for list of all states with their meta data based on country code passed
 *
 * @returns {Promise} Promise object for all states
 */
const getStates = (_countryCode) => {
    const countryCode = _countryCode.toUpperCase();
    if (!I18NIFY_DATA_SUPPORTED_COUNTRIES.includes(countryCode)) {
        return Promise.reject(new Error(`Invalid country code: ${countryCode}. Please ensure you provide a valid country code. Check valid country codes here: https://github.com/razorpay/i18nify/blob/master/i18nify-data/country/metadata/data.json`));
    }
    return fetch(`${I18NIFY_DATA_SOURCE}/country/subdivisions/${countryCode}.json`)
        .then((res) => res.json())
        .then((res) => res.states)
        .catch((err) => {
        throw new Error(`An error occurred while fetching state data. The error details are: ${err.message}.`);
    });
};
var getStates$1 = withErrorBoundary(getStates);

/**
 * Retrieves the list of all cities of a state
 *
 * This function makes a network request to central i18nify-data source and
 * returns a promise for list of all cities with their meta data based on country and state code passed
 *
 * @returns {Promise} Promise object for all cities
 */
const getCities = (_countryCode, _stateCode) => {
    const countryCode = _countryCode.toUpperCase();
    const stateCode = _stateCode && _stateCode.toUpperCase();
    if (!I18NIFY_DATA_SUPPORTED_COUNTRIES.includes(countryCode)) {
        return Promise.reject(new Error(`Invalid country code: ${countryCode}. Please ensure you provide a valid country code. Check valid country codes here: https://github.com/razorpay/i18nify/blob/master/i18nify-data/country/metadata/data.json`));
    }
    return fetch(`${I18NIFY_DATA_SOURCE}/country/subdivisions/${countryCode}.json`)
        .then((res) => res.json())
        .then((res) => {
        // return cities from all states if state code is not provided
        if (!stateCode) {
            return Object.keys(res.states).reduce((acc, curr) => {
                acc = [...acc, ...res.states[curr].cities];
                return acc;
            }, []);
        }
        if (!res.states[stateCode]) {
            return Promise.reject(new Error(`State code ${stateCode} is missing in ${countryCode}. Please ensure you provide a valid state code that exists within the specified country.`));
        }
        return res.states[stateCode].cities;
    })
        .catch((err) => {
        throw new Error(`An error occurred while fetching city data. The error details are: ${err.message}.`);
    });
};
var getCities$1 = withErrorBoundary(getCities);

/**
 * Queries the response received from i18nify-data and returns a list of zipcodes within the state provided
 * @param response i18nify-data country specific response
 * @param stateCode code assigned to the State
 * @returns array of all zipcodes present in state provided
 */
function getZipcodesFromState(response, stateCode) {
    const zipcodes = response.states[stateCode].cities.reduce((_acc, city) => [
        ..._acc,
        ...city.zipcodes,
    ], []);
    // remove duplicate zipcodes
    return [...new Set(zipcodes)];
}
/**
 * Retrieves the list of all cities of a state
 *
 * This function makes a network request to central i18nify-data source and
 * returns a promise for list of all cities with their meta data based on country and state code passed
 *
 * @returns {Promise} Promise object for all cities
 */
const getZipcodes = (_countryCode, _stateCode) => {
    const countryCode = _countryCode.toUpperCase();
    const stateCode = _stateCode && _stateCode.toUpperCase();
    if (!I18NIFY_DATA_SUPPORTED_COUNTRIES.includes(countryCode)) {
        return Promise.reject(new Error(`Invalid country code: ${countryCode}. Please ensure you provide a valid country code.`));
    }
    return fetch(`${I18NIFY_DATA_SOURCE}/country/subdivisions/${countryCode}.json`)
        .then((res) => res.json())
        .then((res) => {
        // return zipcodes of all states if state code is not provided
        if (!stateCode) {
            return Object.keys(res.states).reduce((acc, state) => {
                const stateZipcodes = getZipcodesFromState(res, state);
                return [...acc, ...stateZipcodes];
            }, []);
        }
        if (!res.states[stateCode]) {
            return Promise.reject(`State code ${stateCode} is missing in ${countryCode}. Please ensure you provide a valid state code that exists within the specified country. Check valid state codes and country codes here: https://github.com/razorpay/i18nify/blob/master/i18nify-data/country/metadata/data.json`);
        }
        return getZipcodesFromState(res, stateCode);
    })
        .catch((err) => {
        throw new Error(`An error occurred while fetching zipcode data. The error details are: ${err}.`);
    });
};
var getZipcodes$1 = withErrorBoundary(getZipcodes);

exports.CalendarDate = $35ea8db9cb2ccb90$export$99faa760c7908e4f;
exports.CalendarDateTime = $35ea8db9cb2ccb90$export$ca871e8dbb80966f;
exports.Time = $35ea8db9cb2ccb90$export$680ea196effce5f;
exports.ZonedDateTime = $35ea8db9cb2ccb90$export$d3b7288e7994edea;
exports.convertToMajorUnit = convertToMajorUnit$1;
exports.convertToMinorUnit = convertToMinorUnit$1;
exports.formatDateTime = formatDateTime$1;
exports.formatNumber = formatNumber$1;
exports.formatNumberByParts = formatNumberByParts$1;
exports.formatPhoneNumber = formatPhoneNumber$1;
exports.getAllCountries = getAllCountries$1;
exports.getCities = getCities$1;
exports.getCurrencyList = getCurrencyList$1;
exports.getCurrencySymbol = getCurrencySymbol$1;
exports.getDialCodeByCountryCode = getDialCodeByCountryCode$1;
exports.getDialCodes = getDialCodes$1;
exports.getFlagOfCountry = getFlagOfCountry$1;
exports.getFlagsForAllCountries = getFlagsForAllCountries$1;
exports.getMaskedPhoneNumber = getMaskedPhoneNumber$1;
exports.getRelativeTime = getRelativeTime$1;
exports.getState = getState$1;
exports.getStates = getStates$1;
exports.getWeekdays = getWeekdays$1;
exports.getZipcodes = getZipcodes$1;
exports.isValidPhoneNumber = isValidPhoneNumber$1;
exports.parseDateTime = parseDateTime$1;
exports.parsePhoneNumber = parsePhoneNumber$1;
exports.resetState = resetState$1;
exports.setState = setState$1;
