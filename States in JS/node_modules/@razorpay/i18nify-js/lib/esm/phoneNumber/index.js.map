{"version":3,"file":"index.js","sources":["../../../src/modules/phoneNumber/utils.ts","../../../src/modules/phoneNumber/isValidPhoneNumber.ts","../../../src/modules/phoneNumber/formatPhoneNumber.ts","../../../src/modules/phoneNumber/parsePhoneNumber.ts","../../../src/modules/phoneNumber/getDialCodes.ts","../../../src/modules/phoneNumber/getDialCodeByCountryCode.ts","../../../src/modules/phoneNumber/constants.ts","../../../src/modules/phoneNumber/getMaskedPhoneNumber.ts"],"sourcesContent":["import { CountryCodeType } from '../types';\nimport DIAL_CODE_MAPPER from '#/i18nify-data/phone-number/dial-code-to-country/data.json';\nimport PHONE_REGEX_MAPPER from './data/phoneRegexMapper.json';\n\n/**\n * Determines the country data (countryCode, dialCode) based on the provided phone number.\n * This function employs a multi-step approach to identify the country code:\n * - If the phone number starts with '+', it extracts the numeric characters\n *   and matches the leading digits with known dial codes mapped to countries.\n * - For matched dial codes, it further filters based on country-specific regex patterns\n *   to validate the phone number format for those countries.\n * - If the phone number doesn't start with '+', it returns empty strings as dialCode and countryCode\n *\n * @param phoneNumber The input phone number (string or number).\n * @returns The detected countryCode & dialCode or an empty strings in both if not found.\n */\nexport const detectCountryAndDialCodeFromPhone = (\n  phoneNumber: string | number,\n): { countryCode: CountryCodeType; dialCode: string } => {\n  const regexMapper = PHONE_REGEX_MAPPER;\n\n  // If the phone number starts with '+', extract numeric characters\n  if (phoneNumber.toString().charAt(0) === '+') {\n    const cleanedPhoneNumberWithoutPlusPrefix = phoneNumber\n      .toString()\n      .replace(/\\D/g, '');\n\n    const matchingCountries: Array<{\n      countryCode: CountryCodeType;\n      dialCode: string;\n    }> = [];\n\n    const dialCodeMap = DIAL_CODE_MAPPER.dial_code_to_country as Record<\n      string,\n      CountryCodeType[]\n    >;\n    // Iterate through dial codes and check for matches with cleaned phone number\n    for (const code in dialCodeMap) {\n      if (cleanedPhoneNumberWithoutPlusPrefix.startsWith(code)) {\n        matchingCountries.push(\n          ...(dialCodeMap[code] as string[]).map((item) => ({\n            countryCode: item as CountryCodeType,\n            dialCode: `+${code}`,\n          })),\n        );\n      }\n    }\n\n    // Filter matching countries based on phone number validation regex\n    const matchedCountryCode = matchingCountries.find((country) => {\n      const phoneNumberWithoutDialCode = String(phoneNumber).replace(\n        country.dialCode,\n        '',\n      );\n\n      const regex = regexMapper[country.countryCode as CountryCodeType];\n      if (\n        regex &&\n        matchesEntirely(phoneNumberWithoutDialCode as string, regex as string)\n      )\n        return country;\n      return undefined;\n    });\n\n    // Return the first matched country code, if any\n    return (\n      matchedCountryCode || {\n        countryCode: '' as CountryCodeType,\n        dialCode: '',\n      }\n    );\n  }\n\n  // Return empty string if no country code is detected\n  return { countryCode: '' as CountryCodeType, dialCode: '' };\n};\n\nexport const getPhoneNumberWithoutDialCode = (phoneNumber: string | number) => {\n  const cleanedPhoneNumber = cleanPhoneNumber(String(phoneNumber));\n  const { dialCode } = detectCountryAndDialCodeFromPhone(cleanedPhoneNumber);\n\n  return String(cleanedPhoneNumber).replace(dialCode, '');\n};\n\nexport const cleanPhoneNumber = (phoneNumber: string) => {\n  // Regular expression to match all characters except numbers and + sign at the start\n  const regex = /[^0-9+]|(?!A)\\+/g;\n  // Replace matched characters with an empty string\n  const cleanedPhoneNumber = phoneNumber.replace(regex, '');\n  return phoneNumber[0] === '+' ? `+${cleanedPhoneNumber}` : cleanedPhoneNumber;\n};\n\n/**\n * Replaces the first `n` occurrences of 'x' in a source string with the first `n` characters from a replacement string.\n *\n * @param source {string} - The original string where replacements are to be made.\n * @param replacement {string} - The string from which replacement characters are taken.\n * @param n {number} - The number of 'x' characters to replace (unmasked digit count).\n * @returns {string} - The modified string after replacements.\n */\nexport const suffixMasking = (\n  source: string,\n  replacement: string,\n  n: number,\n): string => {\n  // Convert the source string into an array of characters for easy manipulation\n  const result: string[] = source.split('');\n  let replaceIndex: number = 0;\n  let replacementsDone: number = 0;\n\n  // Iterate over the result array to replace 'x' with characters from the replacement string\n  for (let i = 0; i < result.length && replacementsDone < n; i++) {\n    if (result[i] === 'x' && replaceIndex < replacement.length) {\n      result[i] = replacement[replaceIndex++];\n      replacementsDone++;\n    }\n  }\n\n  // Join the array back into a string and return the modified result\n  return result.join('');\n};\n\n/**\n * Replaces the last `n` occurrences of 'x' in a source string with the last `n` characters from a replacement string.\n *\n * @param source {string} - The original string where replacements are to be made.\n * @param replacement {string} - The string from which replacement characters are taken.\n * @param n {number} - The number of 'x' characters to replace from the end of the source string  (unmasked digit count).\n * @returns {string} - The modified string after replacements.\n */\nexport const prefixMasking = (\n  source: string,\n  replacement: string,\n  n: number,\n): string => {\n  // Convert the source string into an array of characters for easy manipulation\n  const result: string[] = source.split('');\n  let replaceIndex: number = replacement.length - 1;\n  let replacementsDone: number = 0;\n\n  // Iterate from the end of the source string\n  for (let i = result.length - 1; i >= 0 && replacementsDone < n; i--) {\n    if (result[i] === 'x' && replaceIndex >= 0) {\n      result[i] = replacement[replaceIndex--];\n      replacementsDone++;\n    }\n  }\n\n  // Join the array back into a string and return the modified result\n  return result.join('');\n};\n\n/**\n * Replaces every alternate digit of phone number with 'x' in phoneNumberWithoutDialCode.\n *\n * @param phoneNumberWithoutDialCode {number | string} - The original phone number without dial code where replacements are to be made.\n * @returns {string} - The modified string after replacements.\n */\nexport const alternateMasking = (\n  phoneNumberWithoutDialCode: number | string,\n): string => {\n  return String(phoneNumberWithoutDialCode)\n    .trim()\n    .split('')\n    .reduce(\n      (acc: any, char: string) => {\n        if (/\\d/.test(char)) {\n          acc.numericCount % 2 !== 0\n            ? acc.result.push('x')\n            : acc.result.push(char);\n          acc.numericCount++;\n        }\n        return acc;\n      },\n      { result: [], numericCount: 0 },\n    )\n    .result.join('');\n};\n\nexport const matchesEntirely = (text: string, regular_expression: string) => {\n  text = text || '';\n  return new RegExp('^(?:' + regular_expression + ')$').test(text);\n};\n","import PHONE_REGEX_MAPPER from './data/phoneRegexMapper.json';\nimport { withErrorBoundary } from '../../common/errorBoundary';\nimport {\n  detectCountryAndDialCodeFromPhone,\n  cleanPhoneNumber,\n  matchesEntirely,\n  getPhoneNumberWithoutDialCode,\n} from './utils';\nimport { CountryCodeType } from '../types';\n\n// Validates whether a given phone number is valid based on the provided country code or auto-detects the country code and checks if the number matches the defined regex pattern for that country.\nconst isValidPhoneNumber = (\n  phoneNumber: string | number,\n  countryCode?: CountryCodeType,\n): boolean => {\n  // Clean the provided phoneNumber by removing non-numeric characters\n  const cleanedPhoneNumber = cleanPhoneNumber(phoneNumber.toString());\n  if (!cleanedPhoneNumber) return false;\n\n  const regexMapper = PHONE_REGEX_MAPPER;\n  const phoneInfo = detectCountryAndDialCodeFromPhone(cleanedPhoneNumber);\n  // Detect or validate the country code\n  countryCode = (\n    countryCode && countryCode in regexMapper\n      ? countryCode\n      : phoneInfo.countryCode\n  ) as CountryCodeType;\n\n  // Return false if phoneNumber is empty\n  if (!phoneNumber) return false;\n\n  // Check if the countryCode exists in the PHONE_REGEX_MAPPER\n  if (countryCode in regexMapper) {\n    const phoneNumberWithoutDialCode =\n      getPhoneNumberWithoutDialCode(cleanedPhoneNumber);\n\n    // Fetch the regex pattern for the countryCode\n    const regex = regexMapper[countryCode];\n    // Test if the cleanedPhoneNumber matches the regex pattern\n    return matchesEntirely(\n      phoneNumberWithoutDialCode as string,\n      regex as string,\n    );\n  }\n\n  // Return false if the countryCode is not supported\n  return false;\n};\n\nexport default withErrorBoundary<typeof isValidPhoneNumber>(isValidPhoneNumber);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport { CountryCodeType } from '../types';\nimport PHONE_FORMATTER_MAPPER from './data/phoneFormatterMapper.json';\nimport { detectCountryAndDialCodeFromPhone, cleanPhoneNumber } from './utils';\n\n// Formats a provided phone number according to the predefined format for a specific country code, or auto-detects the country code and formats the number accordingly.\nconst formatPhoneNumber = (\n  phoneNumber: string | number,\n  countryCode?: CountryCodeType,\n): string => {\n  // Throw errors if phoneNumber is invalid\n  if (!phoneNumber)\n    throw new Error(\n      `Parameter 'phoneNumber' is invalid! The received value was: ${phoneNumber}. Please ensure you provide a valid phone number.`,\n    );\n\n  // Convert phoneNumber to string and clean it by removing non-numeric characters\n  phoneNumber = phoneNumber.toString();\n  phoneNumber = cleanPhoneNumber(phoneNumber);\n\n  const formatterMap = PHONE_FORMATTER_MAPPER;\n  // Detect or validate the country code\n  countryCode = (\n    countryCode && countryCode in formatterMap\n      ? countryCode\n      : detectCountryAndDialCodeFromPhone(phoneNumber).countryCode\n  ) as CountryCodeType;\n\n  // Fetch the pattern for the countryCode from the PHONE_FORMATTER_MAPPER\n  const pattern = formatterMap[countryCode];\n\n  if (!pattern) return phoneNumber;\n\n  // Count the number of 'x' characters in the format pattern\n  let charCountInFormatterPattern = 0;\n  for (let i = 0; i < pattern.length; i++) {\n    if (pattern[i] === 'x') {\n      charCountInFormatterPattern++;\n    }\n  }\n\n  // Calculate the difference between phoneNumber length and 'x' characters count in pattern\n  const diff = phoneNumber.length - charCountInFormatterPattern;\n  // Extract the phoneNumber without the prefix\n  const phoneNumberWithoutPrefix = phoneNumber.slice(diff);\n  const formattedNumber: string[] = [];\n  let numberIndex = 0;\n\n  // Loop through the pattern to format the phoneNumber\n  for (let i = 0; i < pattern.length; i++) {\n    const patternChar = pattern[i];\n    if (patternChar === 'x') {\n      // Insert phoneNumber digits at 'x' positions\n      if (numberIndex < phoneNumberWithoutPrefix.length) {\n        formattedNumber.push(phoneNumberWithoutPrefix[numberIndex]);\n        numberIndex++;\n      }\n    } else {\n      // Insert non-digit characters from the pattern\n      formattedNumber.push(patternChar);\n    }\n  }\n\n  // Join the formattedNumber array to create the formattedPhoneNumber without prefix\n  const formattedPhoneNumberWithoutPrefix = formattedNumber.join('');\n  // Combine the prefix and formattedPhoneNumberWithoutPrefix\n  const formattedPhoneNumberWithPrefix =\n    phoneNumber.slice(0, diff) + ' ' + formattedPhoneNumberWithoutPrefix;\n\n  // Return the formattedPhoneNumber with prefix after trimming whitespace\n  return formattedPhoneNumberWithPrefix.trim();\n};\n\nexport default withErrorBoundary<typeof formatPhoneNumber>(formatPhoneNumber);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport { CountryCodeType } from '../types';\nimport PHONE_FORMATTER_MAPPER from './data/phoneFormatterMapper.json';\nimport formatPhoneNumber from './formatPhoneNumber';\nimport { detectCountryAndDialCodeFromPhone, cleanPhoneNumber } from './utils';\n\ninterface PhoneInfo {\n  countryCode: string;\n  dialCode: string;\n  formattedPhoneNumber: string;\n  formatTemplate: string;\n  phoneNumber: string;\n}\n\n// Parses a given phone number, identifies its country code (if not provided), and returns an object with details including the country code, formatted phone number, dial code, and format template.\nconst parsePhoneNumber = (\n  phoneNumber: string,\n  country?: CountryCodeType,\n): PhoneInfo => {\n  // Throw errors if phoneNumber is invalid\n  if (!phoneNumber)\n    throw new Error(\n      `Parameter 'phoneNumber' is invalid! The received value was: ${phoneNumber}. Please ensure you provide a valid phone number.`,\n    );\n\n  // Clean the phoneNumber by removing non-numeric characters\n  phoneNumber = phoneNumber.toString();\n  phoneNumber = cleanPhoneNumber(phoneNumber);\n\n  const countryData = detectCountryAndDialCodeFromPhone(phoneNumber);\n  const formatterMap = PHONE_FORMATTER_MAPPER;\n\n  // Detect or validate the country code\n  const countryCode = (\n    country && country in formatterMap ? country : countryData.countryCode\n  ) as CountryCodeType;\n\n  const dialCode = countryData.dialCode;\n  // Format the phone number using the detected/validated country code\n  const formattedPhoneNumber = formatPhoneNumber(phoneNumber, countryCode);\n\n  // Fetch the pattern associated with the countryCode from the PHONE_FORMATTER_MAPPER\n  const pattern = formatterMap[countryCode];\n\n  if (!pattern)\n    return {\n      countryCode,\n      dialCode,\n      formattedPhoneNumber: phoneNumber,\n      formatTemplate: '',\n      phoneNumber,\n    };\n\n  // Count the number of 'x' characters in the format pattern\n  let charCountInFormatterPattern = 0;\n  for (let i = 0; i < pattern.length; i++) {\n    if (pattern[i] === 'x') {\n      charCountInFormatterPattern++;\n    }\n  }\n\n  // Calculate the difference between phoneNumber length and 'x' characters count in pattern\n  const diff = phoneNumber.length - charCountInFormatterPattern;\n\n  // Obtain the format template associated with the countryCode\n  const formatTemplate = formatterMap[countryCode];\n\n  // Return the parsed phone number information\n  return {\n    phoneNumber: phoneNumber.slice(diff),\n    countryCode,\n    dialCode,\n    formattedPhoneNumber: pattern ? formattedPhoneNumber : phoneNumber,\n    formatTemplate: formatTemplate || '',\n  };\n};\n\nexport default withErrorBoundary<typeof parsePhoneNumber>(parsePhoneNumber);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport { CountryCodeType } from '../types';\nimport DIAL_CODE_MAPPER from '#/i18nify-data/phone-number/dial-code-to-country/data.json';\n\n/**\n * Retrieves a mapping of country codes to their respective international dial codes.\n * @returns {Object} An object where each key is a country code (e.g., 'US', 'CA') and its value is the corresponding dial code (e.g., '+1' for 'US' and 'CA').\n */\nconst getDialCodes = (): { [key in CountryCodeType]: string } => {\n  const countryDialCode: { [key in CountryCodeType]: string } = {} as any;\n\n  for (const [dialCode, countryCodes] of Object.entries(\n    DIAL_CODE_MAPPER.dial_code_to_country,\n  )) {\n    countryCodes.forEach((countryCode) => {\n      countryDialCode[countryCode as CountryCodeType] = `+${Number(dialCode)}`;\n    });\n  }\n\n  return countryDialCode;\n};\n\nexport default withErrorBoundary<typeof getDialCodes>(getDialCodes);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport { CountryCodeType } from '../types';\nimport getDialCodes from './getDialCodes';\n\n/**\n * Retrieves the dial code for a specified country code.\n *\n * @param countryCode The country code for which the dial code is to be retrieved.\n *                    It must be a key of the object returned by the `getDialCodes` function.\n * @returns The corresponding dial code as a string.\n * @throws An error if the provided country code is not found in the dial code mapping.\n */\nconst getDialCodeByCountryCode = (countryCode: CountryCodeType): string => {\n  // Get the mapping of all country codes to their respective dial codes\n  const dialCodeForAllCountries = getDialCodes();\n\n  /** Check if the provided country code exists in the mapping.\n   * Return the corresponding dial code if the country code is valid.\n   * Throw an error if the country code is not found in the mapping\n   * */\n  if (countryCode in dialCodeForAllCountries)\n    return dialCodeForAllCountries[countryCode];\n  else\n    throw new Error(\n      `The provided country code is invalid. The received value was: ${countryCode}. Please ensure you pass a valid country code. Check valid country codes here: https://github.com/razorpay/i18nify/blob/master/i18nify-data/country/metadata/data.json`,\n    );\n};\n\nexport default withErrorBoundary<typeof getDialCodeByCountryCode>(\n  getDialCodeByCountryCode,\n);\n","export enum MaskingStyle {\n  Full = 'full',\n  Prefix = 'prefix',\n  Suffix = 'suffix',\n  Alternate = 'alternate',\n}\n","import getDialCodeByCountryCode from './getDialCodeByCountryCode';\nimport { withErrorBoundary } from '../../common/errorBoundary';\nimport PHONE_FORMATTER_MAPPER from './data/phoneFormatterMapper.json';\nimport {\n  cleanPhoneNumber,\n  detectCountryAndDialCodeFromPhone,\n  suffixMasking,\n  prefixMasking,\n  alternateMasking,\n} from './utils';\nimport { GetMaskedPhoneNumberOptions } from './types';\nimport { MaskingStyle } from './constants';\n\n/**\n * Generates a masked phone number based on provided options.\n * This function handles the complexity of different phone number formats and\n * masking preferences such as complete masking or partial masking of digits.\n *\n * @param {GetMaskedPhoneNumberOptions} options - Options for generating the masked phone number.\n * @param {CountryCodeType} options.countryCode - The country code associated with the phone number.\n * @param {boolean} options.withDialCode - Determines if the dial code should be included in the masked number.\n * @param {string} options.phoneNumber - The actual phone number to mask.\n * @param {MaskingOptions} options.maskingOptions - Options to specify how the masking should be performed.\n * @returns {string} The masked phone number formatted as per the specified options.\n * @throws {Error} Throws an error if both countryCode and phoneNumber are empty or if other input validations fail.\n */\nconst getMaskedPhoneNumber = ({\n  countryCode,\n  withDialCode = true,\n  phoneNumber,\n  maskingOptions = {},\n}: GetMaskedPhoneNumberOptions) => {\n  const {\n    maskingStyle = MaskingStyle.Full,\n    maskedDigitsCount = 0,\n    maskingChar = 'x',\n  } = maskingOptions;\n\n  if (!countryCode && !phoneNumber) {\n    throw new Error(\n      `Either 'countryCode' or 'phoneNumber' is mandatory. Please provide a valid 'countryCode' or 'phoneNumber'. Check valid country codes here: https://github.com/razorpay/i18nify/blob/master/i18nify-data/country/metadata/data.json`,\n    );\n  }\n\n  let maskedContactNumber: string;\n  let dialCode: string;\n\n  if (phoneNumber) {\n    // Clean the phone number to remove any non-numeric characters, except the leading '+'\n    let updatedPhoneNumber = phoneNumber;\n    updatedPhoneNumber = updatedPhoneNumber.toString();\n    updatedPhoneNumber = cleanPhoneNumber(updatedPhoneNumber);\n\n    // Detect the country code and dial code from the cleaned phone number\n    const countryData = detectCountryAndDialCodeFromPhone(updatedPhoneNumber);\n    const updatedCountryCode = countryCode || countryData.countryCode;\n    try {\n      dialCode = getDialCodeByCountryCode(updatedCountryCode);\n    } catch (error) {\n      dialCode = countryData.dialCode;\n    }\n\n    // Extract the phone number without dial code\n    const phoneNumberWithoutDialCode =\n      updatedPhoneNumber[0] === '+'\n        ? updatedPhoneNumber.slice(dialCode.toString().length)\n        : updatedPhoneNumber;\n\n    // Get the phone number formatting template based on the country code\n    const formattingTemplate =\n      PHONE_FORMATTER_MAPPER[updatedCountryCode] ||\n      phoneNumber.replace(/\\d/g, 'x');\n\n    switch (maskingStyle) {\n      case MaskingStyle.Alternate:\n        // Example: 7394926646 --> 7x9x9x6x4x\n        maskedContactNumber = alternateMasking(phoneNumberWithoutDialCode);\n        break;\n      case MaskingStyle.Prefix:\n        // Example: 7394926646 --> xxxx 926646\n        maskedContactNumber = prefixMasking(\n          formattingTemplate,\n          String(phoneNumberWithoutDialCode),\n          phoneNumberWithoutDialCode.length - maskedDigitsCount,\n        );\n        break;\n      case MaskingStyle.Suffix:\n        // Example: 7394926646 --> 7494 92xxxx\n        maskedContactNumber = suffixMasking(\n          formattingTemplate,\n          String(phoneNumberWithoutDialCode),\n          phoneNumberWithoutDialCode.length - maskedDigitsCount,\n        );\n        break;\n      default: // Full Masking Condition\n        maskedContactNumber = formattingTemplate;\n    }\n  } else {\n    // Retrieve the phone number formatting template using the country code\n    maskedContactNumber = PHONE_FORMATTER_MAPPER[countryCode];\n    if (!maskedContactNumber) {\n      throw new Error(\n        `Parameter 'countryCode' is invalid. The received value was: ${countryCode}. Check valid country codes here: https://github.com/razorpay/i18nify/blob/master/i18nify-data/country/metadata/data.json`,\n      );\n    }\n    dialCode = getDialCodeByCountryCode(countryCode);\n  }\n\n  // Include the dial code in the masked phone number if requested\n  if (withDialCode) {\n    return `${dialCode} ${maskedContactNumber.replace(\n      /x/g,\n      maskingChar,\n    )}`.trim();\n  } else {\n    return maskedContactNumber.trim().replace(/x/g, maskingChar);\n  }\n};\n\nexport default withErrorBoundary<typeof getMaskedPhoneNumber>(\n  getMaskedPhoneNumber,\n);\n"],"names":["formatPhoneNumber","getDialCodes","getDialCodeByCountryCode"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;AAWG;AACI,MAAM,iCAAiC,GAAG,CA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"}